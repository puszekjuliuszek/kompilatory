Grammar:

Rule 0     S' -> program
Rule 1     program -> instructions
Rule 2     instructions -> instruction
Rule 3     instructions -> instructions instruction
Rule 4     instruction -> { instructions }
Rule 5     instruction -> BREAK ;
Rule 6     instruction -> CONTINUE ;
Rule 7     instruction -> print_i ;
Rule 8     instruction -> assign ;
Rule 9     instruction -> while_l
Rule 10    instruction -> for_l
Rule 11    instruction -> return_i ;
Rule 12    instruction -> if_i
Rule 13    if_i -> IF ( expr ) instruction ELSE error
Rule 14    if_i -> IF ( expr ) error ELSE instruction  [precedence=right, level=2]
Rule 15    if_i -> IF ( expr ) error  [precedence=right, level=1]
Rule 16    if_i -> IF ( error ) instruction ELSE instruction  [precedence=right, level=2]
Rule 17    if_i -> IF ( error ) instruction  [precedence=right, level=1]
Rule 18    if_i -> IF ( expr ) instruction ELSE instruction  [precedence=right, level=2]
Rule 19    if_i -> IF ( expr ) instruction  [precedence=right, level=1]
Rule 20    while_l -> WHILE ( expr ) error
Rule 21    while_l -> WHILE ( error ) instruction
Rule 22    while_l -> WHILE ( expr ) instruction
Rule 23    for_l -> FOR ID = expr : expr error
Rule 24    for_l -> FOR ID = expr : error instruction
Rule 25    for_l -> FOR ID = error : expr instruction
Rule 26    for_l -> FOR ID = expr : expr instruction
Rule 27    return_i -> RETURN error
Rule 28    return_i -> RETURN expr
Rule 29    return_i -> RETURN
Rule 30    print_i -> PRINT error
Rule 31    print_i -> PRINT printargs
Rule 32    printargs -> expr
Rule 33    printargs -> expr , printargs
Rule 34    expr -> mat_fun ( error )
Rule 35    expr -> mat_fun ( mat_fun_args )
Rule 36    expr -> vector
Rule 37    expr -> expr DOTSUB expr  [precedence=left, level=5]
Rule 38    expr -> expr DOTADD expr  [precedence=left, level=5]
Rule 39    expr -> expr DOTDIV expr  [precedence=left, level=6]
Rule 40    expr -> expr DOTMUL expr  [precedence=left, level=6]
Rule 41    expr -> expr OR expr  [precedence=left, level=4]
Rule 42    expr -> expr AND expr  [precedence=left, level=4]
Rule 43    expr -> expr XOR expr  [precedence=left, level=4]
Rule 44    expr -> expr GREATEREQUAL expr  [precedence=nonassoc, level=3]
Rule 45    expr -> expr LESSEREQUAL expr  [precedence=nonassoc, level=3]
Rule 46    expr -> expr GREATER expr  [precedence=nonassoc, level=3]
Rule 47    expr -> expr LESSER expr  [precedence=nonassoc, level=3]
Rule 48    expr -> expr NOTEQUAL expr  [precedence=nonassoc, level=3]
Rule 49    expr -> expr EQUAL expr  [precedence=nonassoc, level=3]
Rule 50    expr -> expr / expr  [precedence=left, level=6]
Rule 51    expr -> expr * expr  [precedence=left, level=6]
Rule 52    expr -> expr - expr  [precedence=left, level=5]
Rule 53    expr -> expr + expr  [precedence=left, level=5]
Rule 54    expr -> unary
Rule 55    expr -> ( expr )
Rule 56    expr -> var
Rule 57    expr -> FLOATNUM
Rule 58    expr -> INTNUM
Rule 59    expr -> STRING
Rule 60    var -> ID
Rule 61    var -> matel
Rule 62    matel -> ID [ mat_fun_args ]
Rule 63    assign -> var DIVASSIGN error
Rule 64    assign -> var MULASSIGN error
Rule 65    assign -> var SUBASSIGN error
Rule 66    assign -> var ADDASSIGN error
Rule 67    assign -> var = error
Rule 68    assign -> var DIVASSIGN expr
Rule 69    assign -> var MULASSIGN expr
Rule 70    assign -> var SUBASSIGN expr
Rule 71    assign -> var ADDASSIGN expr
Rule 72    assign -> var = expr
Rule 73    unary -> expr '
Rule 74    unary -> NOT expr  [precedence=right, level=7]
Rule 75    unary -> - expr  [precedence=right, level=7]
Rule 76    vector -> [ variables ]
Rule 77    variables -> expr
Rule 78    variables -> variables , expr
Rule 79    mat_fun_args -> expr
Rule 80    mat_fun_args -> mat_fun_args , expr
Rule 81    mat_fun -> ONES
Rule 82    mat_fun -> EYE
Rule 83    mat_fun -> ZEROS

Terminals, with rules where they appear:

'                    : 73
(                    : 13 14 15 16 17 18 19 20 21 22 34 35 55
)                    : 13 14 15 16 17 18 19 20 21 22 34 35 55
*                    : 51
+                    : 53
,                    : 33 78 80
-                    : 52 75
/                    : 50
:                    : 23 24 25 26
;                    : 5 6 7 8 11
=                    : 23 24 25 26 67 72
ADDASSIGN            : 66 71
AND                  : 42
BREAK                : 5
CONTINUE             : 6
DIVASSIGN            : 63 68
DOTADD               : 38
DOTDIV               : 39
DOTMUL               : 40
DOTSUB               : 37
ELSE                 : 13 14 16 18
EQUAL                : 49
EYE                  : 82
FLOATNUM             : 57
FOR                  : 23 24 25 26
GREATER              : 46
GREATEREQUAL         : 44
ID                   : 23 24 25 26 60 62
IF                   : 13 14 15 16 17 18 19
INTNUM               : 58
LESSER               : 47
LESSEREQUAL          : 45
MULASSIGN            : 64 69
NOT                  : 74
NOTEQUAL             : 48
ONES                 : 81
OR                   : 41
PRINT                : 30 31
RETURN               : 27 28 29
STRING               : 59
SUBASSIGN            : 65 70
WHILE                : 20 21 22
XOR                  : 43
ZEROS                : 83
[                    : 62 76
]                    : 62 76
error                : 13 14 15 16 17 20 21 23 24 25 27 30 34 63 64 65 66 67
{                    : 4
}                    : 4

Nonterminals, with rules where they appear:

assign               : 8
expr                 : 13 14 15 18 19 20 22 23 23 24 25 26 26 28 32 33 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 55 68 69 70 71 72 73 74 75 77 78 79 80
for_l                : 10
if_i                 : 12
instruction          : 2 3 13 14 16 16 17 18 18 19 21 22 24 25 26
instructions         : 1 3 4
mat_fun              : 34 35
mat_fun_args         : 35 62 80
matel                : 61
print_i              : 7
printargs            : 31 33
program              : 0
return_i             : 11
unary                : 54
var                  : 56 63 64 65 66 67 68 69 70 71 72
variables            : 76 78
vector               : 36
while_l              : 9


state 0

    (0) S' -> . program
    (1) program -> . instructions
    (2) instructions -> . instruction
    (3) instructions -> . instructions instruction
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    program                        shift and go to state 1
    instructions                   shift and go to state 2
    instruction                    shift and go to state 3
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 1

    (0) S' -> program .


state 2

    (1) program -> instructions .
    (3) instructions -> instructions . instruction
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    $end            reduce using rule 1 (program -> instructions .)
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instruction                    shift and go to state 21
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 3

    (2) instructions -> instruction .
    {               reduce using rule 2 (instructions -> instruction .)
    BREAK           reduce using rule 2 (instructions -> instruction .)
    CONTINUE        reduce using rule 2 (instructions -> instruction .)
    PRINT           reduce using rule 2 (instructions -> instruction .)
    WHILE           reduce using rule 2 (instructions -> instruction .)
    FOR             reduce using rule 2 (instructions -> instruction .)
    RETURN          reduce using rule 2 (instructions -> instruction .)
    IF              reduce using rule 2 (instructions -> instruction .)
    ID              reduce using rule 2 (instructions -> instruction .)
    $end            reduce using rule 2 (instructions -> instruction .)
    }               reduce using rule 2 (instructions -> instruction .)


state 4

    (4) instruction -> { . instructions }
    (2) instructions -> . instruction
    (3) instructions -> . instructions instruction
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instructions                   shift and go to state 22
    instruction                    shift and go to state 3
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 5

    (5) instruction -> BREAK . ;
    ;               shift and go to state 23


state 6

    (6) instruction -> CONTINUE . ;
    ;               shift and go to state 24


state 7

    (7) instruction -> print_i . ;
    ;               shift and go to state 25


state 8

    (8) instruction -> assign . ;
    ;               shift and go to state 26


state 9

    (9) instruction -> while_l .
    {               reduce using rule 9 (instruction -> while_l .)
    BREAK           reduce using rule 9 (instruction -> while_l .)
    CONTINUE        reduce using rule 9 (instruction -> while_l .)
    PRINT           reduce using rule 9 (instruction -> while_l .)
    WHILE           reduce using rule 9 (instruction -> while_l .)
    FOR             reduce using rule 9 (instruction -> while_l .)
    RETURN          reduce using rule 9 (instruction -> while_l .)
    IF              reduce using rule 9 (instruction -> while_l .)
    ID              reduce using rule 9 (instruction -> while_l .)
    $end            reduce using rule 9 (instruction -> while_l .)
    }               reduce using rule 9 (instruction -> while_l .)
    ELSE            reduce using rule 9 (instruction -> while_l .)


state 10

    (10) instruction -> for_l .
    {               reduce using rule 10 (instruction -> for_l .)
    BREAK           reduce using rule 10 (instruction -> for_l .)
    CONTINUE        reduce using rule 10 (instruction -> for_l .)
    PRINT           reduce using rule 10 (instruction -> for_l .)
    WHILE           reduce using rule 10 (instruction -> for_l .)
    FOR             reduce using rule 10 (instruction -> for_l .)
    RETURN          reduce using rule 10 (instruction -> for_l .)
    IF              reduce using rule 10 (instruction -> for_l .)
    ID              reduce using rule 10 (instruction -> for_l .)
    $end            reduce using rule 10 (instruction -> for_l .)
    }               reduce using rule 10 (instruction -> for_l .)
    ELSE            reduce using rule 10 (instruction -> for_l .)


state 11

    (11) instruction -> return_i . ;
    ;               shift and go to state 27


state 12

    (12) instruction -> if_i .
    {               reduce using rule 12 (instruction -> if_i .)
    BREAK           reduce using rule 12 (instruction -> if_i .)
    CONTINUE        reduce using rule 12 (instruction -> if_i .)
    PRINT           reduce using rule 12 (instruction -> if_i .)
    WHILE           reduce using rule 12 (instruction -> if_i .)
    FOR             reduce using rule 12 (instruction -> if_i .)
    RETURN          reduce using rule 12 (instruction -> if_i .)
    IF              reduce using rule 12 (instruction -> if_i .)
    ID              reduce using rule 12 (instruction -> if_i .)
    $end            reduce using rule 12 (instruction -> if_i .)
    }               reduce using rule 12 (instruction -> if_i .)
    ELSE            reduce using rule 12 (instruction -> if_i .)


state 13

    (30) print_i -> PRINT . error
    (31) print_i -> PRINT . printargs
    (32) printargs -> . expr
    (33) printargs -> . expr , printargs
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 28
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    printargs                      shift and go to state 29
    expr                           shift and go to state 30
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 14

    (63) assign -> var . DIVASSIGN error
    (64) assign -> var . MULASSIGN error
    (65) assign -> var . SUBASSIGN error
    (66) assign -> var . ADDASSIGN error
    (67) assign -> var . = error
    (68) assign -> var . DIVASSIGN expr
    (69) assign -> var . MULASSIGN expr
    (70) assign -> var . SUBASSIGN expr
    (71) assign -> var . ADDASSIGN expr
    (72) assign -> var . = expr
    DIVASSIGN       shift and go to state 45
    MULASSIGN       shift and go to state 46
    SUBASSIGN       shift and go to state 47
    ADDASSIGN       shift and go to state 48
    =               shift and go to state 49


state 15

    (20) while_l -> WHILE . ( expr ) error
    (21) while_l -> WHILE . ( error ) instruction
    (22) while_l -> WHILE . ( expr ) instruction
    (               shift and go to state 50


state 16

    (23) for_l -> FOR . ID = expr : expr error
    (24) for_l -> FOR . ID = expr : error instruction
    (25) for_l -> FOR . ID = error : expr instruction
    (26) for_l -> FOR . ID = expr : expr instruction
    ID              shift and go to state 51


state 17

    (60) var -> ID .
    (62) matel -> ID . [ mat_fun_args ]
    DIVASSIGN       reduce using rule 60 (var -> ID .)
    MULASSIGN       reduce using rule 60 (var -> ID .)
    SUBASSIGN       reduce using rule 60 (var -> ID .)
    ADDASSIGN       reduce using rule 60 (var -> ID .)
    =               reduce using rule 60 (var -> ID .)
    ,               reduce using rule 60 (var -> ID .)
    DOTSUB          reduce using rule 60 (var -> ID .)
    DOTADD          reduce using rule 60 (var -> ID .)
    DOTDIV          reduce using rule 60 (var -> ID .)
    DOTMUL          reduce using rule 60 (var -> ID .)
    OR              reduce using rule 60 (var -> ID .)
    AND             reduce using rule 60 (var -> ID .)
    XOR             reduce using rule 60 (var -> ID .)
    GREATEREQUAL    reduce using rule 60 (var -> ID .)
    LESSEREQUAL     reduce using rule 60 (var -> ID .)
    GREATER         reduce using rule 60 (var -> ID .)
    LESSER          reduce using rule 60 (var -> ID .)
    NOTEQUAL        reduce using rule 60 (var -> ID .)
    EQUAL           reduce using rule 60 (var -> ID .)
    /               reduce using rule 60 (var -> ID .)
    *               reduce using rule 60 (var -> ID .)
    -               reduce using rule 60 (var -> ID .)
    +               reduce using rule 60 (var -> ID .)
    '               reduce using rule 60 (var -> ID .)
    ;               reduce using rule 60 (var -> ID .)
    )               reduce using rule 60 (var -> ID .)
    ]               reduce using rule 60 (var -> ID .)
    :               reduce using rule 60 (var -> ID .)
    error           reduce using rule 60 (var -> ID .)
    {               reduce using rule 60 (var -> ID .)
    BREAK           reduce using rule 60 (var -> ID .)
    CONTINUE        reduce using rule 60 (var -> ID .)
    PRINT           reduce using rule 60 (var -> ID .)
    WHILE           reduce using rule 60 (var -> ID .)
    FOR             reduce using rule 60 (var -> ID .)
    RETURN          reduce using rule 60 (var -> ID .)
    IF              reduce using rule 60 (var -> ID .)
    ID              reduce using rule 60 (var -> ID .)
    [               shift and go to state 52


state 18

    (27) return_i -> RETURN . error
    (28) return_i -> RETURN . expr
    (29) return_i -> RETURN .
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 53
    ;               reduce using rule 29 (return_i -> RETURN .)
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 54
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 19

    (13) if_i -> IF . ( expr ) instruction ELSE error
    (14) if_i -> IF . ( expr ) error ELSE instruction
    (15) if_i -> IF . ( expr ) error
    (16) if_i -> IF . ( error ) instruction ELSE instruction
    (17) if_i -> IF . ( error ) instruction
    (18) if_i -> IF . ( expr ) instruction ELSE instruction
    (19) if_i -> IF . ( expr ) instruction
    (               shift and go to state 55


state 20

    (61) var -> matel .
    DIVASSIGN       reduce using rule 61 (var -> matel .)
    MULASSIGN       reduce using rule 61 (var -> matel .)
    SUBASSIGN       reduce using rule 61 (var -> matel .)
    ADDASSIGN       reduce using rule 61 (var -> matel .)
    =               reduce using rule 61 (var -> matel .)
    ,               reduce using rule 61 (var -> matel .)
    DOTSUB          reduce using rule 61 (var -> matel .)
    DOTADD          reduce using rule 61 (var -> matel .)
    DOTDIV          reduce using rule 61 (var -> matel .)
    DOTMUL          reduce using rule 61 (var -> matel .)
    OR              reduce using rule 61 (var -> matel .)
    AND             reduce using rule 61 (var -> matel .)
    XOR             reduce using rule 61 (var -> matel .)
    GREATEREQUAL    reduce using rule 61 (var -> matel .)
    LESSEREQUAL     reduce using rule 61 (var -> matel .)
    GREATER         reduce using rule 61 (var -> matel .)
    LESSER          reduce using rule 61 (var -> matel .)
    NOTEQUAL        reduce using rule 61 (var -> matel .)
    EQUAL           reduce using rule 61 (var -> matel .)
    /               reduce using rule 61 (var -> matel .)
    *               reduce using rule 61 (var -> matel .)
    -               reduce using rule 61 (var -> matel .)
    +               reduce using rule 61 (var -> matel .)
    '               reduce using rule 61 (var -> matel .)
    ;               reduce using rule 61 (var -> matel .)
    )               reduce using rule 61 (var -> matel .)
    ]               reduce using rule 61 (var -> matel .)
    :               reduce using rule 61 (var -> matel .)
    error           reduce using rule 61 (var -> matel .)
    {               reduce using rule 61 (var -> matel .)
    BREAK           reduce using rule 61 (var -> matel .)
    CONTINUE        reduce using rule 61 (var -> matel .)
    PRINT           reduce using rule 61 (var -> matel .)
    WHILE           reduce using rule 61 (var -> matel .)
    FOR             reduce using rule 61 (var -> matel .)
    RETURN          reduce using rule 61 (var -> matel .)
    IF              reduce using rule 61 (var -> matel .)
    ID              reduce using rule 61 (var -> matel .)


state 21

    (3) instructions -> instructions instruction .
    {               reduce using rule 3 (instructions -> instructions instruction .)
    BREAK           reduce using rule 3 (instructions -> instructions instruction .)
    CONTINUE        reduce using rule 3 (instructions -> instructions instruction .)
    PRINT           reduce using rule 3 (instructions -> instructions instruction .)
    WHILE           reduce using rule 3 (instructions -> instructions instruction .)
    FOR             reduce using rule 3 (instructions -> instructions instruction .)
    RETURN          reduce using rule 3 (instructions -> instructions instruction .)
    IF              reduce using rule 3 (instructions -> instructions instruction .)
    ID              reduce using rule 3 (instructions -> instructions instruction .)
    $end            reduce using rule 3 (instructions -> instructions instruction .)
    }               reduce using rule 3 (instructions -> instructions instruction .)


state 22

    (4) instruction -> { instructions . }
    (3) instructions -> instructions . instruction
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    }               shift and go to state 56
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instruction                    shift and go to state 21
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 23

    (5) instruction -> BREAK ; .
    {               reduce using rule 5 (instruction -> BREAK ; .)
    BREAK           reduce using rule 5 (instruction -> BREAK ; .)
    CONTINUE        reduce using rule 5 (instruction -> BREAK ; .)
    PRINT           reduce using rule 5 (instruction -> BREAK ; .)
    WHILE           reduce using rule 5 (instruction -> BREAK ; .)
    FOR             reduce using rule 5 (instruction -> BREAK ; .)
    RETURN          reduce using rule 5 (instruction -> BREAK ; .)
    IF              reduce using rule 5 (instruction -> BREAK ; .)
    ID              reduce using rule 5 (instruction -> BREAK ; .)
    $end            reduce using rule 5 (instruction -> BREAK ; .)
    }               reduce using rule 5 (instruction -> BREAK ; .)
    ELSE            reduce using rule 5 (instruction -> BREAK ; .)


state 24

    (6) instruction -> CONTINUE ; .
    {               reduce using rule 6 (instruction -> CONTINUE ; .)
    BREAK           reduce using rule 6 (instruction -> CONTINUE ; .)
    CONTINUE        reduce using rule 6 (instruction -> CONTINUE ; .)
    PRINT           reduce using rule 6 (instruction -> CONTINUE ; .)
    WHILE           reduce using rule 6 (instruction -> CONTINUE ; .)
    FOR             reduce using rule 6 (instruction -> CONTINUE ; .)
    RETURN          reduce using rule 6 (instruction -> CONTINUE ; .)
    IF              reduce using rule 6 (instruction -> CONTINUE ; .)
    ID              reduce using rule 6 (instruction -> CONTINUE ; .)
    $end            reduce using rule 6 (instruction -> CONTINUE ; .)
    }               reduce using rule 6 (instruction -> CONTINUE ; .)
    ELSE            reduce using rule 6 (instruction -> CONTINUE ; .)


state 25

    (7) instruction -> print_i ; .
    {               reduce using rule 7 (instruction -> print_i ; .)
    BREAK           reduce using rule 7 (instruction -> print_i ; .)
    CONTINUE        reduce using rule 7 (instruction -> print_i ; .)
    PRINT           reduce using rule 7 (instruction -> print_i ; .)
    WHILE           reduce using rule 7 (instruction -> print_i ; .)
    FOR             reduce using rule 7 (instruction -> print_i ; .)
    RETURN          reduce using rule 7 (instruction -> print_i ; .)
    IF              reduce using rule 7 (instruction -> print_i ; .)
    ID              reduce using rule 7 (instruction -> print_i ; .)
    $end            reduce using rule 7 (instruction -> print_i ; .)
    }               reduce using rule 7 (instruction -> print_i ; .)
    ELSE            reduce using rule 7 (instruction -> print_i ; .)


state 26

    (8) instruction -> assign ; .
    {               reduce using rule 8 (instruction -> assign ; .)
    BREAK           reduce using rule 8 (instruction -> assign ; .)
    CONTINUE        reduce using rule 8 (instruction -> assign ; .)
    PRINT           reduce using rule 8 (instruction -> assign ; .)
    WHILE           reduce using rule 8 (instruction -> assign ; .)
    FOR             reduce using rule 8 (instruction -> assign ; .)
    RETURN          reduce using rule 8 (instruction -> assign ; .)
    IF              reduce using rule 8 (instruction -> assign ; .)
    ID              reduce using rule 8 (instruction -> assign ; .)
    $end            reduce using rule 8 (instruction -> assign ; .)
    }               reduce using rule 8 (instruction -> assign ; .)
    ELSE            reduce using rule 8 (instruction -> assign ; .)


state 27

    (11) instruction -> return_i ; .
    {               reduce using rule 11 (instruction -> return_i ; .)
    BREAK           reduce using rule 11 (instruction -> return_i ; .)
    CONTINUE        reduce using rule 11 (instruction -> return_i ; .)
    PRINT           reduce using rule 11 (instruction -> return_i ; .)
    WHILE           reduce using rule 11 (instruction -> return_i ; .)
    FOR             reduce using rule 11 (instruction -> return_i ; .)
    RETURN          reduce using rule 11 (instruction -> return_i ; .)
    IF              reduce using rule 11 (instruction -> return_i ; .)
    ID              reduce using rule 11 (instruction -> return_i ; .)
    $end            reduce using rule 11 (instruction -> return_i ; .)
    }               reduce using rule 11 (instruction -> return_i ; .)
    ELSE            reduce using rule 11 (instruction -> return_i ; .)


state 28

    (30) print_i -> PRINT error .
    ;               reduce using rule 30 (print_i -> PRINT error .)


state 29

    (31) print_i -> PRINT printargs .
    ;               reduce using rule 31 (print_i -> PRINT printargs .)


state 30

    (32) printargs -> expr .
    (33) printargs -> expr . , printargs
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ;               reduce using rule 32 (printargs -> expr .)
    ,               shift and go to state 57
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 31

    (34) expr -> mat_fun . ( error )
    (35) expr -> mat_fun . ( mat_fun_args )
    (               shift and go to state 76


state 32

    (55) expr -> ( . expr )
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 77
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 33

    (36) expr -> vector .
    ,               reduce using rule 36 (expr -> vector .)
    DOTSUB          reduce using rule 36 (expr -> vector .)
    DOTADD          reduce using rule 36 (expr -> vector .)
    DOTDIV          reduce using rule 36 (expr -> vector .)
    DOTMUL          reduce using rule 36 (expr -> vector .)
    OR              reduce using rule 36 (expr -> vector .)
    AND             reduce using rule 36 (expr -> vector .)
    XOR             reduce using rule 36 (expr -> vector .)
    GREATEREQUAL    reduce using rule 36 (expr -> vector .)
    LESSEREQUAL     reduce using rule 36 (expr -> vector .)
    GREATER         reduce using rule 36 (expr -> vector .)
    LESSER          reduce using rule 36 (expr -> vector .)
    NOTEQUAL        reduce using rule 36 (expr -> vector .)
    EQUAL           reduce using rule 36 (expr -> vector .)
    /               reduce using rule 36 (expr -> vector .)
    *               reduce using rule 36 (expr -> vector .)
    -               reduce using rule 36 (expr -> vector .)
    +               reduce using rule 36 (expr -> vector .)
    '               reduce using rule 36 (expr -> vector .)
    ;               reduce using rule 36 (expr -> vector .)
    )               reduce using rule 36 (expr -> vector .)
    ]               reduce using rule 36 (expr -> vector .)
    :               reduce using rule 36 (expr -> vector .)
    error           reduce using rule 36 (expr -> vector .)
    {               reduce using rule 36 (expr -> vector .)
    BREAK           reduce using rule 36 (expr -> vector .)
    CONTINUE        reduce using rule 36 (expr -> vector .)
    PRINT           reduce using rule 36 (expr -> vector .)
    WHILE           reduce using rule 36 (expr -> vector .)
    FOR             reduce using rule 36 (expr -> vector .)
    RETURN          reduce using rule 36 (expr -> vector .)
    IF              reduce using rule 36 (expr -> vector .)
    ID              reduce using rule 36 (expr -> vector .)


state 34

    (75) unary -> - . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 78
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 35

    (54) expr -> unary .
    ,               reduce using rule 54 (expr -> unary .)
    DOTSUB          reduce using rule 54 (expr -> unary .)
    DOTADD          reduce using rule 54 (expr -> unary .)
    DOTDIV          reduce using rule 54 (expr -> unary .)
    DOTMUL          reduce using rule 54 (expr -> unary .)
    OR              reduce using rule 54 (expr -> unary .)
    AND             reduce using rule 54 (expr -> unary .)
    XOR             reduce using rule 54 (expr -> unary .)
    GREATEREQUAL    reduce using rule 54 (expr -> unary .)
    LESSEREQUAL     reduce using rule 54 (expr -> unary .)
    GREATER         reduce using rule 54 (expr -> unary .)
    LESSER          reduce using rule 54 (expr -> unary .)
    NOTEQUAL        reduce using rule 54 (expr -> unary .)
    EQUAL           reduce using rule 54 (expr -> unary .)
    /               reduce using rule 54 (expr -> unary .)
    *               reduce using rule 54 (expr -> unary .)
    -               reduce using rule 54 (expr -> unary .)
    +               reduce using rule 54 (expr -> unary .)
    '               reduce using rule 54 (expr -> unary .)
    ;               reduce using rule 54 (expr -> unary .)
    )               reduce using rule 54 (expr -> unary .)
    ]               reduce using rule 54 (expr -> unary .)
    :               reduce using rule 54 (expr -> unary .)
    error           reduce using rule 54 (expr -> unary .)
    {               reduce using rule 54 (expr -> unary .)
    BREAK           reduce using rule 54 (expr -> unary .)
    CONTINUE        reduce using rule 54 (expr -> unary .)
    PRINT           reduce using rule 54 (expr -> unary .)
    WHILE           reduce using rule 54 (expr -> unary .)
    FOR             reduce using rule 54 (expr -> unary .)
    RETURN          reduce using rule 54 (expr -> unary .)
    IF              reduce using rule 54 (expr -> unary .)
    ID              reduce using rule 54 (expr -> unary .)


state 36

    (56) expr -> var .
    ,               reduce using rule 56 (expr -> var .)
    DOTSUB          reduce using rule 56 (expr -> var .)
    DOTADD          reduce using rule 56 (expr -> var .)
    DOTDIV          reduce using rule 56 (expr -> var .)
    DOTMUL          reduce using rule 56 (expr -> var .)
    OR              reduce using rule 56 (expr -> var .)
    AND             reduce using rule 56 (expr -> var .)
    XOR             reduce using rule 56 (expr -> var .)
    GREATEREQUAL    reduce using rule 56 (expr -> var .)
    LESSEREQUAL     reduce using rule 56 (expr -> var .)
    GREATER         reduce using rule 56 (expr -> var .)
    LESSER          reduce using rule 56 (expr -> var .)
    NOTEQUAL        reduce using rule 56 (expr -> var .)
    EQUAL           reduce using rule 56 (expr -> var .)
    /               reduce using rule 56 (expr -> var .)
    *               reduce using rule 56 (expr -> var .)
    -               reduce using rule 56 (expr -> var .)
    +               reduce using rule 56 (expr -> var .)
    '               reduce using rule 56 (expr -> var .)
    ;               reduce using rule 56 (expr -> var .)
    )               reduce using rule 56 (expr -> var .)
    ]               reduce using rule 56 (expr -> var .)
    :               reduce using rule 56 (expr -> var .)
    error           reduce using rule 56 (expr -> var .)
    {               reduce using rule 56 (expr -> var .)
    BREAK           reduce using rule 56 (expr -> var .)
    CONTINUE        reduce using rule 56 (expr -> var .)
    PRINT           reduce using rule 56 (expr -> var .)
    WHILE           reduce using rule 56 (expr -> var .)
    FOR             reduce using rule 56 (expr -> var .)
    RETURN          reduce using rule 56 (expr -> var .)
    IF              reduce using rule 56 (expr -> var .)
    ID              reduce using rule 56 (expr -> var .)


state 37

    (57) expr -> FLOATNUM .
    ,               reduce using rule 57 (expr -> FLOATNUM .)
    DOTSUB          reduce using rule 57 (expr -> FLOATNUM .)
    DOTADD          reduce using rule 57 (expr -> FLOATNUM .)
    DOTDIV          reduce using rule 57 (expr -> FLOATNUM .)
    DOTMUL          reduce using rule 57 (expr -> FLOATNUM .)
    OR              reduce using rule 57 (expr -> FLOATNUM .)
    AND             reduce using rule 57 (expr -> FLOATNUM .)
    XOR             reduce using rule 57 (expr -> FLOATNUM .)
    GREATEREQUAL    reduce using rule 57 (expr -> FLOATNUM .)
    LESSEREQUAL     reduce using rule 57 (expr -> FLOATNUM .)
    GREATER         reduce using rule 57 (expr -> FLOATNUM .)
    LESSER          reduce using rule 57 (expr -> FLOATNUM .)
    NOTEQUAL        reduce using rule 57 (expr -> FLOATNUM .)
    EQUAL           reduce using rule 57 (expr -> FLOATNUM .)
    /               reduce using rule 57 (expr -> FLOATNUM .)
    *               reduce using rule 57 (expr -> FLOATNUM .)
    -               reduce using rule 57 (expr -> FLOATNUM .)
    +               reduce using rule 57 (expr -> FLOATNUM .)
    '               reduce using rule 57 (expr -> FLOATNUM .)
    ;               reduce using rule 57 (expr -> FLOATNUM .)
    )               reduce using rule 57 (expr -> FLOATNUM .)
    ]               reduce using rule 57 (expr -> FLOATNUM .)
    :               reduce using rule 57 (expr -> FLOATNUM .)
    error           reduce using rule 57 (expr -> FLOATNUM .)
    {               reduce using rule 57 (expr -> FLOATNUM .)
    BREAK           reduce using rule 57 (expr -> FLOATNUM .)
    CONTINUE        reduce using rule 57 (expr -> FLOATNUM .)
    PRINT           reduce using rule 57 (expr -> FLOATNUM .)
    WHILE           reduce using rule 57 (expr -> FLOATNUM .)
    FOR             reduce using rule 57 (expr -> FLOATNUM .)
    RETURN          reduce using rule 57 (expr -> FLOATNUM .)
    IF              reduce using rule 57 (expr -> FLOATNUM .)
    ID              reduce using rule 57 (expr -> FLOATNUM .)


state 38

    (58) expr -> INTNUM .
    ,               reduce using rule 58 (expr -> INTNUM .)
    DOTSUB          reduce using rule 58 (expr -> INTNUM .)
    DOTADD          reduce using rule 58 (expr -> INTNUM .)
    DOTDIV          reduce using rule 58 (expr -> INTNUM .)
    DOTMUL          reduce using rule 58 (expr -> INTNUM .)
    OR              reduce using rule 58 (expr -> INTNUM .)
    AND             reduce using rule 58 (expr -> INTNUM .)
    XOR             reduce using rule 58 (expr -> INTNUM .)
    GREATEREQUAL    reduce using rule 58 (expr -> INTNUM .)
    LESSEREQUAL     reduce using rule 58 (expr -> INTNUM .)
    GREATER         reduce using rule 58 (expr -> INTNUM .)
    LESSER          reduce using rule 58 (expr -> INTNUM .)
    NOTEQUAL        reduce using rule 58 (expr -> INTNUM .)
    EQUAL           reduce using rule 58 (expr -> INTNUM .)
    /               reduce using rule 58 (expr -> INTNUM .)
    *               reduce using rule 58 (expr -> INTNUM .)
    -               reduce using rule 58 (expr -> INTNUM .)
    +               reduce using rule 58 (expr -> INTNUM .)
    '               reduce using rule 58 (expr -> INTNUM .)
    ;               reduce using rule 58 (expr -> INTNUM .)
    )               reduce using rule 58 (expr -> INTNUM .)
    ]               reduce using rule 58 (expr -> INTNUM .)
    :               reduce using rule 58 (expr -> INTNUM .)
    error           reduce using rule 58 (expr -> INTNUM .)
    {               reduce using rule 58 (expr -> INTNUM .)
    BREAK           reduce using rule 58 (expr -> INTNUM .)
    CONTINUE        reduce using rule 58 (expr -> INTNUM .)
    PRINT           reduce using rule 58 (expr -> INTNUM .)
    WHILE           reduce using rule 58 (expr -> INTNUM .)
    FOR             reduce using rule 58 (expr -> INTNUM .)
    RETURN          reduce using rule 58 (expr -> INTNUM .)
    IF              reduce using rule 58 (expr -> INTNUM .)
    ID              reduce using rule 58 (expr -> INTNUM .)


state 39

    (59) expr -> STRING .
    ,               reduce using rule 59 (expr -> STRING .)
    DOTSUB          reduce using rule 59 (expr -> STRING .)
    DOTADD          reduce using rule 59 (expr -> STRING .)
    DOTDIV          reduce using rule 59 (expr -> STRING .)
    DOTMUL          reduce using rule 59 (expr -> STRING .)
    OR              reduce using rule 59 (expr -> STRING .)
    AND             reduce using rule 59 (expr -> STRING .)
    XOR             reduce using rule 59 (expr -> STRING .)
    GREATEREQUAL    reduce using rule 59 (expr -> STRING .)
    LESSEREQUAL     reduce using rule 59 (expr -> STRING .)
    GREATER         reduce using rule 59 (expr -> STRING .)
    LESSER          reduce using rule 59 (expr -> STRING .)
    NOTEQUAL        reduce using rule 59 (expr -> STRING .)
    EQUAL           reduce using rule 59 (expr -> STRING .)
    /               reduce using rule 59 (expr -> STRING .)
    *               reduce using rule 59 (expr -> STRING .)
    -               reduce using rule 59 (expr -> STRING .)
    +               reduce using rule 59 (expr -> STRING .)
    '               reduce using rule 59 (expr -> STRING .)
    ;               reduce using rule 59 (expr -> STRING .)
    )               reduce using rule 59 (expr -> STRING .)
    ]               reduce using rule 59 (expr -> STRING .)
    :               reduce using rule 59 (expr -> STRING .)
    error           reduce using rule 59 (expr -> STRING .)
    {               reduce using rule 59 (expr -> STRING .)
    BREAK           reduce using rule 59 (expr -> STRING .)
    CONTINUE        reduce using rule 59 (expr -> STRING .)
    PRINT           reduce using rule 59 (expr -> STRING .)
    WHILE           reduce using rule 59 (expr -> STRING .)
    FOR             reduce using rule 59 (expr -> STRING .)
    RETURN          reduce using rule 59 (expr -> STRING .)
    IF              reduce using rule 59 (expr -> STRING .)
    ID              reduce using rule 59 (expr -> STRING .)


state 40

    (81) mat_fun -> ONES .
    (               reduce using rule 81 (mat_fun -> ONES .)


state 41

    (82) mat_fun -> EYE .
    (               reduce using rule 82 (mat_fun -> EYE .)


state 42

    (83) mat_fun -> ZEROS .
    (               reduce using rule 83 (mat_fun -> ZEROS .)


state 43

    (76) vector -> [ . variables ]
    (77) variables -> . expr
    (78) variables -> . variables , expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    variables                      shift and go to state 79
    expr                           shift and go to state 80
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 44

    (74) unary -> NOT . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 81
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 45

    (63) assign -> var DIVASSIGN . error
    (68) assign -> var DIVASSIGN . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 82
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    var                            shift and go to state 36
    expr                           shift and go to state 83
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    matel                          shift and go to state 20

state 46

    (64) assign -> var MULASSIGN . error
    (69) assign -> var MULASSIGN . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 84
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    var                            shift and go to state 36
    expr                           shift and go to state 85
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    matel                          shift and go to state 20

state 47

    (65) assign -> var SUBASSIGN . error
    (70) assign -> var SUBASSIGN . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 86
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    var                            shift and go to state 36
    expr                           shift and go to state 87
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    matel                          shift and go to state 20

state 48

    (66) assign -> var ADDASSIGN . error
    (71) assign -> var ADDASSIGN . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 88
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    var                            shift and go to state 36
    expr                           shift and go to state 89
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    matel                          shift and go to state 20

state 49

    (67) assign -> var = . error
    (72) assign -> var = . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 90
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    var                            shift and go to state 36
    expr                           shift and go to state 91
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    matel                          shift and go to state 20

state 50

    (20) while_l -> WHILE ( . expr ) error
    (21) while_l -> WHILE ( . error ) instruction
    (22) while_l -> WHILE ( . expr ) instruction
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 93
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 92
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 51

    (23) for_l -> FOR ID . = expr : expr error
    (24) for_l -> FOR ID . = expr : error instruction
    (25) for_l -> FOR ID . = error : expr instruction
    (26) for_l -> FOR ID . = expr : expr instruction
    =               shift and go to state 94


state 52

    (62) matel -> ID [ . mat_fun_args ]
    (79) mat_fun_args -> . expr
    (80) mat_fun_args -> . mat_fun_args , expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    mat_fun_args                   shift and go to state 95
    expr                           shift and go to state 96
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 53

    (27) return_i -> RETURN error .
    ;               reduce using rule 27 (return_i -> RETURN error .)


state 54

    (28) return_i -> RETURN expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ;               reduce using rule 28 (return_i -> RETURN expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 55

    (13) if_i -> IF ( . expr ) instruction ELSE error
    (14) if_i -> IF ( . expr ) error ELSE instruction
    (15) if_i -> IF ( . expr ) error
    (16) if_i -> IF ( . error ) instruction ELSE instruction
    (17) if_i -> IF ( . error ) instruction
    (18) if_i -> IF ( . expr ) instruction ELSE instruction
    (19) if_i -> IF ( . expr ) instruction
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 98
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 97
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 56

    (4) instruction -> { instructions } .
    {               reduce using rule 4 (instruction -> { instructions } .)
    BREAK           reduce using rule 4 (instruction -> { instructions } .)
    CONTINUE        reduce using rule 4 (instruction -> { instructions } .)
    PRINT           reduce using rule 4 (instruction -> { instructions } .)
    WHILE           reduce using rule 4 (instruction -> { instructions } .)
    FOR             reduce using rule 4 (instruction -> { instructions } .)
    RETURN          reduce using rule 4 (instruction -> { instructions } .)
    IF              reduce using rule 4 (instruction -> { instructions } .)
    ID              reduce using rule 4 (instruction -> { instructions } .)
    $end            reduce using rule 4 (instruction -> { instructions } .)
    }               reduce using rule 4 (instruction -> { instructions } .)
    ELSE            reduce using rule 4 (instruction -> { instructions } .)


state 57

    (33) printargs -> expr , . printargs
    (32) printargs -> . expr
    (33) printargs -> . expr , printargs
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 30
    printargs                      shift and go to state 99
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 58

    (37) expr -> expr DOTSUB . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 100
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 59

    (38) expr -> expr DOTADD . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 101
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 60

    (39) expr -> expr DOTDIV . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 102
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 61

    (40) expr -> expr DOTMUL . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 103
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 62

    (41) expr -> expr OR . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 104
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 63

    (42) expr -> expr AND . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 105
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 64

    (43) expr -> expr XOR . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 106
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 65

    (44) expr -> expr GREATEREQUAL . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 107
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 66

    (45) expr -> expr LESSEREQUAL . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 108
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 67

    (46) expr -> expr GREATER . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 109
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 68

    (47) expr -> expr LESSER . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 110
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 69

    (48) expr -> expr NOTEQUAL . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 111
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 70

    (49) expr -> expr EQUAL . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 112
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 71

    (50) expr -> expr / . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 113
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 72

    (51) expr -> expr * . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 114
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 73

    (52) expr -> expr - . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 115
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 74

    (53) expr -> expr + . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 116
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 75

    (73) unary -> expr ' .
    ,               reduce using rule 73 (unary -> expr ' .)
    DOTSUB          reduce using rule 73 (unary -> expr ' .)
    DOTADD          reduce using rule 73 (unary -> expr ' .)
    DOTDIV          reduce using rule 73 (unary -> expr ' .)
    DOTMUL          reduce using rule 73 (unary -> expr ' .)
    OR              reduce using rule 73 (unary -> expr ' .)
    AND             reduce using rule 73 (unary -> expr ' .)
    XOR             reduce using rule 73 (unary -> expr ' .)
    GREATEREQUAL    reduce using rule 73 (unary -> expr ' .)
    LESSEREQUAL     reduce using rule 73 (unary -> expr ' .)
    GREATER         reduce using rule 73 (unary -> expr ' .)
    LESSER          reduce using rule 73 (unary -> expr ' .)
    NOTEQUAL        reduce using rule 73 (unary -> expr ' .)
    EQUAL           reduce using rule 73 (unary -> expr ' .)
    /               reduce using rule 73 (unary -> expr ' .)
    *               reduce using rule 73 (unary -> expr ' .)
    -               reduce using rule 73 (unary -> expr ' .)
    +               reduce using rule 73 (unary -> expr ' .)
    '               reduce using rule 73 (unary -> expr ' .)
    ;               reduce using rule 73 (unary -> expr ' .)
    )               reduce using rule 73 (unary -> expr ' .)
    ]               reduce using rule 73 (unary -> expr ' .)
    :               reduce using rule 73 (unary -> expr ' .)
    error           reduce using rule 73 (unary -> expr ' .)
    {               reduce using rule 73 (unary -> expr ' .)
    BREAK           reduce using rule 73 (unary -> expr ' .)
    CONTINUE        reduce using rule 73 (unary -> expr ' .)
    PRINT           reduce using rule 73 (unary -> expr ' .)
    WHILE           reduce using rule 73 (unary -> expr ' .)
    FOR             reduce using rule 73 (unary -> expr ' .)
    RETURN          reduce using rule 73 (unary -> expr ' .)
    IF              reduce using rule 73 (unary -> expr ' .)
    ID              reduce using rule 73 (unary -> expr ' .)


state 76

    (34) expr -> mat_fun ( . error )
    (35) expr -> mat_fun ( . mat_fun_args )
    (79) mat_fun_args -> . expr
    (80) mat_fun_args -> . mat_fun_args , expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 117
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    mat_fun                        shift and go to state 31
    mat_fun_args                   shift and go to state 118
    expr                           shift and go to state 96
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 77

    (55) expr -> ( expr . )
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    )               shift and go to state 119
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 78

    (75) unary -> - expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 75 (unary -> - expr .)
    DOTSUB          reduce using rule 75 (unary -> - expr .)
    DOTADD          reduce using rule 75 (unary -> - expr .)
    DOTDIV          reduce using rule 75 (unary -> - expr .)
    DOTMUL          reduce using rule 75 (unary -> - expr .)
    OR              reduce using rule 75 (unary -> - expr .)
    AND             reduce using rule 75 (unary -> - expr .)
    XOR             reduce using rule 75 (unary -> - expr .)
    GREATEREQUAL    reduce using rule 75 (unary -> - expr .)
    LESSEREQUAL     reduce using rule 75 (unary -> - expr .)
    GREATER         reduce using rule 75 (unary -> - expr .)
    LESSER          reduce using rule 75 (unary -> - expr .)
    NOTEQUAL        reduce using rule 75 (unary -> - expr .)
    EQUAL           reduce using rule 75 (unary -> - expr .)
    /               reduce using rule 75 (unary -> - expr .)
    *               reduce using rule 75 (unary -> - expr .)
    -               reduce using rule 75 (unary -> - expr .)
    +               reduce using rule 75 (unary -> - expr .)
    '               reduce using rule 75 (unary -> - expr .)
    ;               reduce using rule 75 (unary -> - expr .)
    )               reduce using rule 75 (unary -> - expr .)
    ]               reduce using rule 75 (unary -> - expr .)
    :               reduce using rule 75 (unary -> - expr .)
    error           reduce using rule 75 (unary -> - expr .)
    {               reduce using rule 75 (unary -> - expr .)
    BREAK           reduce using rule 75 (unary -> - expr .)
    CONTINUE        reduce using rule 75 (unary -> - expr .)
    PRINT           reduce using rule 75 (unary -> - expr .)
    WHILE           reduce using rule 75 (unary -> - expr .)
    FOR             reduce using rule 75 (unary -> - expr .)
    RETURN          reduce using rule 75 (unary -> - expr .)
    IF              reduce using rule 75 (unary -> - expr .)
    ID              reduce using rule 75 (unary -> - expr .)


state 79

    (76) vector -> [ variables . ]
    (78) variables -> variables . , expr
    ]               shift and go to state 120
    ,               shift and go to state 121


state 80

    (77) variables -> expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ]               reduce using rule 77 (variables -> expr .)
    ,               reduce using rule 77 (variables -> expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 81

    (74) unary -> NOT expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 74 (unary -> NOT expr .)
    DOTSUB          reduce using rule 74 (unary -> NOT expr .)
    DOTADD          reduce using rule 74 (unary -> NOT expr .)
    DOTDIV          reduce using rule 74 (unary -> NOT expr .)
    DOTMUL          reduce using rule 74 (unary -> NOT expr .)
    OR              reduce using rule 74 (unary -> NOT expr .)
    AND             reduce using rule 74 (unary -> NOT expr .)
    XOR             reduce using rule 74 (unary -> NOT expr .)
    GREATEREQUAL    reduce using rule 74 (unary -> NOT expr .)
    LESSEREQUAL     reduce using rule 74 (unary -> NOT expr .)
    GREATER         reduce using rule 74 (unary -> NOT expr .)
    LESSER          reduce using rule 74 (unary -> NOT expr .)
    NOTEQUAL        reduce using rule 74 (unary -> NOT expr .)
    EQUAL           reduce using rule 74 (unary -> NOT expr .)
    /               reduce using rule 74 (unary -> NOT expr .)
    *               reduce using rule 74 (unary -> NOT expr .)
    -               reduce using rule 74 (unary -> NOT expr .)
    +               reduce using rule 74 (unary -> NOT expr .)
    '               reduce using rule 74 (unary -> NOT expr .)
    ;               reduce using rule 74 (unary -> NOT expr .)
    )               reduce using rule 74 (unary -> NOT expr .)
    ]               reduce using rule 74 (unary -> NOT expr .)
    :               reduce using rule 74 (unary -> NOT expr .)
    error           reduce using rule 74 (unary -> NOT expr .)
    {               reduce using rule 74 (unary -> NOT expr .)
    BREAK           reduce using rule 74 (unary -> NOT expr .)
    CONTINUE        reduce using rule 74 (unary -> NOT expr .)
    PRINT           reduce using rule 74 (unary -> NOT expr .)
    WHILE           reduce using rule 74 (unary -> NOT expr .)
    FOR             reduce using rule 74 (unary -> NOT expr .)
    RETURN          reduce using rule 74 (unary -> NOT expr .)
    IF              reduce using rule 74 (unary -> NOT expr .)
    ID              reduce using rule 74 (unary -> NOT expr .)


state 82

    (63) assign -> var DIVASSIGN error .
    ;               reduce using rule 63 (assign -> var DIVASSIGN error .)


state 83

    (68) assign -> var DIVASSIGN expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ;               reduce using rule 68 (assign -> var DIVASSIGN expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 84

    (64) assign -> var MULASSIGN error .
    ;               reduce using rule 64 (assign -> var MULASSIGN error .)


state 85

    (69) assign -> var MULASSIGN expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ;               reduce using rule 69 (assign -> var MULASSIGN expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 86

    (65) assign -> var SUBASSIGN error .
    ;               reduce using rule 65 (assign -> var SUBASSIGN error .)


state 87

    (70) assign -> var SUBASSIGN expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ;               reduce using rule 70 (assign -> var SUBASSIGN expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 88

    (66) assign -> var ADDASSIGN error .
    ;               reduce using rule 66 (assign -> var ADDASSIGN error .)


state 89

    (71) assign -> var ADDASSIGN expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ;               reduce using rule 71 (assign -> var ADDASSIGN expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 90

    (67) assign -> var = error .
    ;               reduce using rule 67 (assign -> var = error .)


state 91

    (72) assign -> var = expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ;               reduce using rule 72 (assign -> var = expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 92

    (20) while_l -> WHILE ( expr . ) error
    (22) while_l -> WHILE ( expr . ) instruction
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    )               shift and go to state 122
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 93

    (21) while_l -> WHILE ( error . ) instruction
    )               shift and go to state 123


state 94

    (23) for_l -> FOR ID = . expr : expr error
    (24) for_l -> FOR ID = . expr : error instruction
    (25) for_l -> FOR ID = . error : expr instruction
    (26) for_l -> FOR ID = . expr : expr instruction
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 125
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 124
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 95

    (62) matel -> ID [ mat_fun_args . ]
    (80) mat_fun_args -> mat_fun_args . , expr
    ]               shift and go to state 126
    ,               shift and go to state 127


state 96

    (79) mat_fun_args -> expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ]               reduce using rule 79 (mat_fun_args -> expr .)
    ,               reduce using rule 79 (mat_fun_args -> expr .)
    )               reduce using rule 79 (mat_fun_args -> expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 97

    (13) if_i -> IF ( expr . ) instruction ELSE error
    (14) if_i -> IF ( expr . ) error ELSE instruction
    (15) if_i -> IF ( expr . ) error
    (18) if_i -> IF ( expr . ) instruction ELSE instruction
    (19) if_i -> IF ( expr . ) instruction
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    )               shift and go to state 128
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 98

    (16) if_i -> IF ( error . ) instruction ELSE instruction
    (17) if_i -> IF ( error . ) instruction
    )               shift and go to state 129


state 99

    (33) printargs -> expr , printargs .
    ;               reduce using rule 33 (printargs -> expr , printargs .)


state 100

    (37) expr -> expr DOTSUB expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 37 (expr -> expr DOTSUB expr .)
    DOTSUB          reduce using rule 37 (expr -> expr DOTSUB expr .)
    DOTADD          reduce using rule 37 (expr -> expr DOTSUB expr .)
    OR              reduce using rule 37 (expr -> expr DOTSUB expr .)
    AND             reduce using rule 37 (expr -> expr DOTSUB expr .)
    XOR             reduce using rule 37 (expr -> expr DOTSUB expr .)
    GREATEREQUAL    reduce using rule 37 (expr -> expr DOTSUB expr .)
    LESSEREQUAL     reduce using rule 37 (expr -> expr DOTSUB expr .)
    GREATER         reduce using rule 37 (expr -> expr DOTSUB expr .)
    LESSER          reduce using rule 37 (expr -> expr DOTSUB expr .)
    NOTEQUAL        reduce using rule 37 (expr -> expr DOTSUB expr .)
    EQUAL           reduce using rule 37 (expr -> expr DOTSUB expr .)
    -               reduce using rule 37 (expr -> expr DOTSUB expr .)
    +               reduce using rule 37 (expr -> expr DOTSUB expr .)
    '               reduce using rule 37 (expr -> expr DOTSUB expr .)
    ;               reduce using rule 37 (expr -> expr DOTSUB expr .)
    )               reduce using rule 37 (expr -> expr DOTSUB expr .)
    ]               reduce using rule 37 (expr -> expr DOTSUB expr .)
    :               reduce using rule 37 (expr -> expr DOTSUB expr .)
    error           reduce using rule 37 (expr -> expr DOTSUB expr .)
    {               reduce using rule 37 (expr -> expr DOTSUB expr .)
    BREAK           reduce using rule 37 (expr -> expr DOTSUB expr .)
    CONTINUE        reduce using rule 37 (expr -> expr DOTSUB expr .)
    PRINT           reduce using rule 37 (expr -> expr DOTSUB expr .)
    WHILE           reduce using rule 37 (expr -> expr DOTSUB expr .)
    FOR             reduce using rule 37 (expr -> expr DOTSUB expr .)
    RETURN          reduce using rule 37 (expr -> expr DOTSUB expr .)
    IF              reduce using rule 37 (expr -> expr DOTSUB expr .)
    ID              reduce using rule 37 (expr -> expr DOTSUB expr .)
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    /               shift and go to state 71
    *               shift and go to state 72


state 101

    (38) expr -> expr DOTADD expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 38 (expr -> expr DOTADD expr .)
    DOTSUB          reduce using rule 38 (expr -> expr DOTADD expr .)
    DOTADD          reduce using rule 38 (expr -> expr DOTADD expr .)
    OR              reduce using rule 38 (expr -> expr DOTADD expr .)
    AND             reduce using rule 38 (expr -> expr DOTADD expr .)
    XOR             reduce using rule 38 (expr -> expr DOTADD expr .)
    GREATEREQUAL    reduce using rule 38 (expr -> expr DOTADD expr .)
    LESSEREQUAL     reduce using rule 38 (expr -> expr DOTADD expr .)
    GREATER         reduce using rule 38 (expr -> expr DOTADD expr .)
    LESSER          reduce using rule 38 (expr -> expr DOTADD expr .)
    NOTEQUAL        reduce using rule 38 (expr -> expr DOTADD expr .)
    EQUAL           reduce using rule 38 (expr -> expr DOTADD expr .)
    -               reduce using rule 38 (expr -> expr DOTADD expr .)
    +               reduce using rule 38 (expr -> expr DOTADD expr .)
    '               reduce using rule 38 (expr -> expr DOTADD expr .)
    ;               reduce using rule 38 (expr -> expr DOTADD expr .)
    )               reduce using rule 38 (expr -> expr DOTADD expr .)
    ]               reduce using rule 38 (expr -> expr DOTADD expr .)
    :               reduce using rule 38 (expr -> expr DOTADD expr .)
    error           reduce using rule 38 (expr -> expr DOTADD expr .)
    {               reduce using rule 38 (expr -> expr DOTADD expr .)
    BREAK           reduce using rule 38 (expr -> expr DOTADD expr .)
    CONTINUE        reduce using rule 38 (expr -> expr DOTADD expr .)
    PRINT           reduce using rule 38 (expr -> expr DOTADD expr .)
    WHILE           reduce using rule 38 (expr -> expr DOTADD expr .)
    FOR             reduce using rule 38 (expr -> expr DOTADD expr .)
    RETURN          reduce using rule 38 (expr -> expr DOTADD expr .)
    IF              reduce using rule 38 (expr -> expr DOTADD expr .)
    ID              reduce using rule 38 (expr -> expr DOTADD expr .)
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    /               shift and go to state 71
    *               shift and go to state 72


state 102

    (39) expr -> expr DOTDIV expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 39 (expr -> expr DOTDIV expr .)
    DOTSUB          reduce using rule 39 (expr -> expr DOTDIV expr .)
    DOTADD          reduce using rule 39 (expr -> expr DOTDIV expr .)
    DOTDIV          reduce using rule 39 (expr -> expr DOTDIV expr .)
    DOTMUL          reduce using rule 39 (expr -> expr DOTDIV expr .)
    OR              reduce using rule 39 (expr -> expr DOTDIV expr .)
    AND             reduce using rule 39 (expr -> expr DOTDIV expr .)
    XOR             reduce using rule 39 (expr -> expr DOTDIV expr .)
    GREATEREQUAL    reduce using rule 39 (expr -> expr DOTDIV expr .)
    LESSEREQUAL     reduce using rule 39 (expr -> expr DOTDIV expr .)
    GREATER         reduce using rule 39 (expr -> expr DOTDIV expr .)
    LESSER          reduce using rule 39 (expr -> expr DOTDIV expr .)
    NOTEQUAL        reduce using rule 39 (expr -> expr DOTDIV expr .)
    EQUAL           reduce using rule 39 (expr -> expr DOTDIV expr .)
    /               reduce using rule 39 (expr -> expr DOTDIV expr .)
    *               reduce using rule 39 (expr -> expr DOTDIV expr .)
    -               reduce using rule 39 (expr -> expr DOTDIV expr .)
    +               reduce using rule 39 (expr -> expr DOTDIV expr .)
    '               reduce using rule 39 (expr -> expr DOTDIV expr .)
    ;               reduce using rule 39 (expr -> expr DOTDIV expr .)
    )               reduce using rule 39 (expr -> expr DOTDIV expr .)
    ]               reduce using rule 39 (expr -> expr DOTDIV expr .)
    :               reduce using rule 39 (expr -> expr DOTDIV expr .)
    error           reduce using rule 39 (expr -> expr DOTDIV expr .)
    {               reduce using rule 39 (expr -> expr DOTDIV expr .)
    BREAK           reduce using rule 39 (expr -> expr DOTDIV expr .)
    CONTINUE        reduce using rule 39 (expr -> expr DOTDIV expr .)
    PRINT           reduce using rule 39 (expr -> expr DOTDIV expr .)
    WHILE           reduce using rule 39 (expr -> expr DOTDIV expr .)
    FOR             reduce using rule 39 (expr -> expr DOTDIV expr .)
    RETURN          reduce using rule 39 (expr -> expr DOTDIV expr .)
    IF              reduce using rule 39 (expr -> expr DOTDIV expr .)
    ID              reduce using rule 39 (expr -> expr DOTDIV expr .)


state 103

    (40) expr -> expr DOTMUL expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 40 (expr -> expr DOTMUL expr .)
    DOTSUB          reduce using rule 40 (expr -> expr DOTMUL expr .)
    DOTADD          reduce using rule 40 (expr -> expr DOTMUL expr .)
    DOTDIV          reduce using rule 40 (expr -> expr DOTMUL expr .)
    DOTMUL          reduce using rule 40 (expr -> expr DOTMUL expr .)
    OR              reduce using rule 40 (expr -> expr DOTMUL expr .)
    AND             reduce using rule 40 (expr -> expr DOTMUL expr .)
    XOR             reduce using rule 40 (expr -> expr DOTMUL expr .)
    GREATEREQUAL    reduce using rule 40 (expr -> expr DOTMUL expr .)
    LESSEREQUAL     reduce using rule 40 (expr -> expr DOTMUL expr .)
    GREATER         reduce using rule 40 (expr -> expr DOTMUL expr .)
    LESSER          reduce using rule 40 (expr -> expr DOTMUL expr .)
    NOTEQUAL        reduce using rule 40 (expr -> expr DOTMUL expr .)
    EQUAL           reduce using rule 40 (expr -> expr DOTMUL expr .)
    /               reduce using rule 40 (expr -> expr DOTMUL expr .)
    *               reduce using rule 40 (expr -> expr DOTMUL expr .)
    -               reduce using rule 40 (expr -> expr DOTMUL expr .)
    +               reduce using rule 40 (expr -> expr DOTMUL expr .)
    '               reduce using rule 40 (expr -> expr DOTMUL expr .)
    ;               reduce using rule 40 (expr -> expr DOTMUL expr .)
    )               reduce using rule 40 (expr -> expr DOTMUL expr .)
    ]               reduce using rule 40 (expr -> expr DOTMUL expr .)
    :               reduce using rule 40 (expr -> expr DOTMUL expr .)
    error           reduce using rule 40 (expr -> expr DOTMUL expr .)
    {               reduce using rule 40 (expr -> expr DOTMUL expr .)
    BREAK           reduce using rule 40 (expr -> expr DOTMUL expr .)
    CONTINUE        reduce using rule 40 (expr -> expr DOTMUL expr .)
    PRINT           reduce using rule 40 (expr -> expr DOTMUL expr .)
    WHILE           reduce using rule 40 (expr -> expr DOTMUL expr .)
    FOR             reduce using rule 40 (expr -> expr DOTMUL expr .)
    RETURN          reduce using rule 40 (expr -> expr DOTMUL expr .)
    IF              reduce using rule 40 (expr -> expr DOTMUL expr .)
    ID              reduce using rule 40 (expr -> expr DOTMUL expr .)


state 104

    (41) expr -> expr OR expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 41 (expr -> expr OR expr .)
    OR              reduce using rule 41 (expr -> expr OR expr .)
    AND             reduce using rule 41 (expr -> expr OR expr .)
    XOR             reduce using rule 41 (expr -> expr OR expr .)
    GREATEREQUAL    reduce using rule 41 (expr -> expr OR expr .)
    LESSEREQUAL     reduce using rule 41 (expr -> expr OR expr .)
    GREATER         reduce using rule 41 (expr -> expr OR expr .)
    LESSER          reduce using rule 41 (expr -> expr OR expr .)
    NOTEQUAL        reduce using rule 41 (expr -> expr OR expr .)
    EQUAL           reduce using rule 41 (expr -> expr OR expr .)
    '               reduce using rule 41 (expr -> expr OR expr .)
    ;               reduce using rule 41 (expr -> expr OR expr .)
    )               reduce using rule 41 (expr -> expr OR expr .)
    ]               reduce using rule 41 (expr -> expr OR expr .)
    :               reduce using rule 41 (expr -> expr OR expr .)
    error           reduce using rule 41 (expr -> expr OR expr .)
    {               reduce using rule 41 (expr -> expr OR expr .)
    BREAK           reduce using rule 41 (expr -> expr OR expr .)
    CONTINUE        reduce using rule 41 (expr -> expr OR expr .)
    PRINT           reduce using rule 41 (expr -> expr OR expr .)
    WHILE           reduce using rule 41 (expr -> expr OR expr .)
    FOR             reduce using rule 41 (expr -> expr OR expr .)
    RETURN          reduce using rule 41 (expr -> expr OR expr .)
    IF              reduce using rule 41 (expr -> expr OR expr .)
    ID              reduce using rule 41 (expr -> expr OR expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74


state 105

    (42) expr -> expr AND expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 42 (expr -> expr AND expr .)
    OR              reduce using rule 42 (expr -> expr AND expr .)
    AND             reduce using rule 42 (expr -> expr AND expr .)
    XOR             reduce using rule 42 (expr -> expr AND expr .)
    GREATEREQUAL    reduce using rule 42 (expr -> expr AND expr .)
    LESSEREQUAL     reduce using rule 42 (expr -> expr AND expr .)
    GREATER         reduce using rule 42 (expr -> expr AND expr .)
    LESSER          reduce using rule 42 (expr -> expr AND expr .)
    NOTEQUAL        reduce using rule 42 (expr -> expr AND expr .)
    EQUAL           reduce using rule 42 (expr -> expr AND expr .)
    '               reduce using rule 42 (expr -> expr AND expr .)
    ;               reduce using rule 42 (expr -> expr AND expr .)
    )               reduce using rule 42 (expr -> expr AND expr .)
    ]               reduce using rule 42 (expr -> expr AND expr .)
    :               reduce using rule 42 (expr -> expr AND expr .)
    error           reduce using rule 42 (expr -> expr AND expr .)
    {               reduce using rule 42 (expr -> expr AND expr .)
    BREAK           reduce using rule 42 (expr -> expr AND expr .)
    CONTINUE        reduce using rule 42 (expr -> expr AND expr .)
    PRINT           reduce using rule 42 (expr -> expr AND expr .)
    WHILE           reduce using rule 42 (expr -> expr AND expr .)
    FOR             reduce using rule 42 (expr -> expr AND expr .)
    RETURN          reduce using rule 42 (expr -> expr AND expr .)
    IF              reduce using rule 42 (expr -> expr AND expr .)
    ID              reduce using rule 42 (expr -> expr AND expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74


state 106

    (43) expr -> expr XOR expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 43 (expr -> expr XOR expr .)
    OR              reduce using rule 43 (expr -> expr XOR expr .)
    AND             reduce using rule 43 (expr -> expr XOR expr .)
    XOR             reduce using rule 43 (expr -> expr XOR expr .)
    GREATEREQUAL    reduce using rule 43 (expr -> expr XOR expr .)
    LESSEREQUAL     reduce using rule 43 (expr -> expr XOR expr .)
    GREATER         reduce using rule 43 (expr -> expr XOR expr .)
    LESSER          reduce using rule 43 (expr -> expr XOR expr .)
    NOTEQUAL        reduce using rule 43 (expr -> expr XOR expr .)
    EQUAL           reduce using rule 43 (expr -> expr XOR expr .)
    '               reduce using rule 43 (expr -> expr XOR expr .)
    ;               reduce using rule 43 (expr -> expr XOR expr .)
    )               reduce using rule 43 (expr -> expr XOR expr .)
    ]               reduce using rule 43 (expr -> expr XOR expr .)
    :               reduce using rule 43 (expr -> expr XOR expr .)
    error           reduce using rule 43 (expr -> expr XOR expr .)
    {               reduce using rule 43 (expr -> expr XOR expr .)
    BREAK           reduce using rule 43 (expr -> expr XOR expr .)
    CONTINUE        reduce using rule 43 (expr -> expr XOR expr .)
    PRINT           reduce using rule 43 (expr -> expr XOR expr .)
    WHILE           reduce using rule 43 (expr -> expr XOR expr .)
    FOR             reduce using rule 43 (expr -> expr XOR expr .)
    RETURN          reduce using rule 43 (expr -> expr XOR expr .)
    IF              reduce using rule 43 (expr -> expr XOR expr .)
    ID              reduce using rule 43 (expr -> expr XOR expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74


state 107

    (44) expr -> expr GREATEREQUAL expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    GREATEREQUAL    reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    LESSEREQUAL     reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    GREATER         reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    LESSER          reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    NOTEQUAL        reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    EQUAL           reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    '               reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    ;               reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    )               reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    ]               reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    :               reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    error           reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    {               reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    BREAK           reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    CONTINUE        reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    PRINT           reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    WHILE           reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    FOR             reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    RETURN          reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    IF              reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    ID              reduce using rule 44 (expr -> expr GREATEREQUAL expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74


state 108

    (45) expr -> expr LESSEREQUAL expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    GREATEREQUAL    reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    LESSEREQUAL     reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    GREATER         reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    LESSER          reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    NOTEQUAL        reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    EQUAL           reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    '               reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    ;               reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    )               reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    ]               reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    :               reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    error           reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    {               reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    BREAK           reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    CONTINUE        reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    PRINT           reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    WHILE           reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    FOR             reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    RETURN          reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    IF              reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    ID              reduce using rule 45 (expr -> expr LESSEREQUAL expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74


state 109

    (46) expr -> expr GREATER expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 46 (expr -> expr GREATER expr .)
    GREATEREQUAL    reduce using rule 46 (expr -> expr GREATER expr .)
    LESSEREQUAL     reduce using rule 46 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 46 (expr -> expr GREATER expr .)
    LESSER          reduce using rule 46 (expr -> expr GREATER expr .)
    NOTEQUAL        reduce using rule 46 (expr -> expr GREATER expr .)
    EQUAL           reduce using rule 46 (expr -> expr GREATER expr .)
    '               reduce using rule 46 (expr -> expr GREATER expr .)
    ;               reduce using rule 46 (expr -> expr GREATER expr .)
    )               reduce using rule 46 (expr -> expr GREATER expr .)
    ]               reduce using rule 46 (expr -> expr GREATER expr .)
    :               reduce using rule 46 (expr -> expr GREATER expr .)
    error           reduce using rule 46 (expr -> expr GREATER expr .)
    {               reduce using rule 46 (expr -> expr GREATER expr .)
    BREAK           reduce using rule 46 (expr -> expr GREATER expr .)
    CONTINUE        reduce using rule 46 (expr -> expr GREATER expr .)
    PRINT           reduce using rule 46 (expr -> expr GREATER expr .)
    WHILE           reduce using rule 46 (expr -> expr GREATER expr .)
    FOR             reduce using rule 46 (expr -> expr GREATER expr .)
    RETURN          reduce using rule 46 (expr -> expr GREATER expr .)
    IF              reduce using rule 46 (expr -> expr GREATER expr .)
    ID              reduce using rule 46 (expr -> expr GREATER expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74


state 110

    (47) expr -> expr LESSER expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 47 (expr -> expr LESSER expr .)
    GREATEREQUAL    reduce using rule 47 (expr -> expr LESSER expr .)
    LESSEREQUAL     reduce using rule 47 (expr -> expr LESSER expr .)
    GREATER         reduce using rule 47 (expr -> expr LESSER expr .)
    LESSER          reduce using rule 47 (expr -> expr LESSER expr .)
    NOTEQUAL        reduce using rule 47 (expr -> expr LESSER expr .)
    EQUAL           reduce using rule 47 (expr -> expr LESSER expr .)
    '               reduce using rule 47 (expr -> expr LESSER expr .)
    ;               reduce using rule 47 (expr -> expr LESSER expr .)
    )               reduce using rule 47 (expr -> expr LESSER expr .)
    ]               reduce using rule 47 (expr -> expr LESSER expr .)
    :               reduce using rule 47 (expr -> expr LESSER expr .)
    error           reduce using rule 47 (expr -> expr LESSER expr .)
    {               reduce using rule 47 (expr -> expr LESSER expr .)
    BREAK           reduce using rule 47 (expr -> expr LESSER expr .)
    CONTINUE        reduce using rule 47 (expr -> expr LESSER expr .)
    PRINT           reduce using rule 47 (expr -> expr LESSER expr .)
    WHILE           reduce using rule 47 (expr -> expr LESSER expr .)
    FOR             reduce using rule 47 (expr -> expr LESSER expr .)
    RETURN          reduce using rule 47 (expr -> expr LESSER expr .)
    IF              reduce using rule 47 (expr -> expr LESSER expr .)
    ID              reduce using rule 47 (expr -> expr LESSER expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74


state 111

    (48) expr -> expr NOTEQUAL expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    GREATEREQUAL    reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    LESSEREQUAL     reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    GREATER         reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    LESSER          reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    NOTEQUAL        reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    EQUAL           reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    '               reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    ;               reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    )               reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    ]               reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    :               reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    error           reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    {               reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    BREAK           reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    CONTINUE        reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    PRINT           reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    WHILE           reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    FOR             reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    RETURN          reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    IF              reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    ID              reduce using rule 48 (expr -> expr NOTEQUAL expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74


state 112

    (49) expr -> expr EQUAL expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 49 (expr -> expr EQUAL expr .)
    GREATEREQUAL    reduce using rule 49 (expr -> expr EQUAL expr .)
    LESSEREQUAL     reduce using rule 49 (expr -> expr EQUAL expr .)
    GREATER         reduce using rule 49 (expr -> expr EQUAL expr .)
    LESSER          reduce using rule 49 (expr -> expr EQUAL expr .)
    NOTEQUAL        reduce using rule 49 (expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 49 (expr -> expr EQUAL expr .)
    '               reduce using rule 49 (expr -> expr EQUAL expr .)
    ;               reduce using rule 49 (expr -> expr EQUAL expr .)
    )               reduce using rule 49 (expr -> expr EQUAL expr .)
    ]               reduce using rule 49 (expr -> expr EQUAL expr .)
    :               reduce using rule 49 (expr -> expr EQUAL expr .)
    error           reduce using rule 49 (expr -> expr EQUAL expr .)
    {               reduce using rule 49 (expr -> expr EQUAL expr .)
    BREAK           reduce using rule 49 (expr -> expr EQUAL expr .)
    CONTINUE        reduce using rule 49 (expr -> expr EQUAL expr .)
    PRINT           reduce using rule 49 (expr -> expr EQUAL expr .)
    WHILE           reduce using rule 49 (expr -> expr EQUAL expr .)
    FOR             reduce using rule 49 (expr -> expr EQUAL expr .)
    RETURN          reduce using rule 49 (expr -> expr EQUAL expr .)
    IF              reduce using rule 49 (expr -> expr EQUAL expr .)
    ID              reduce using rule 49 (expr -> expr EQUAL expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74


state 113

    (50) expr -> expr / expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 50 (expr -> expr / expr .)
    DOTSUB          reduce using rule 50 (expr -> expr / expr .)
    DOTADD          reduce using rule 50 (expr -> expr / expr .)
    DOTDIV          reduce using rule 50 (expr -> expr / expr .)
    DOTMUL          reduce using rule 50 (expr -> expr / expr .)
    OR              reduce using rule 50 (expr -> expr / expr .)
    AND             reduce using rule 50 (expr -> expr / expr .)
    XOR             reduce using rule 50 (expr -> expr / expr .)
    GREATEREQUAL    reduce using rule 50 (expr -> expr / expr .)
    LESSEREQUAL     reduce using rule 50 (expr -> expr / expr .)
    GREATER         reduce using rule 50 (expr -> expr / expr .)
    LESSER          reduce using rule 50 (expr -> expr / expr .)
    NOTEQUAL        reduce using rule 50 (expr -> expr / expr .)
    EQUAL           reduce using rule 50 (expr -> expr / expr .)
    /               reduce using rule 50 (expr -> expr / expr .)
    *               reduce using rule 50 (expr -> expr / expr .)
    -               reduce using rule 50 (expr -> expr / expr .)
    +               reduce using rule 50 (expr -> expr / expr .)
    '               reduce using rule 50 (expr -> expr / expr .)
    ;               reduce using rule 50 (expr -> expr / expr .)
    )               reduce using rule 50 (expr -> expr / expr .)
    ]               reduce using rule 50 (expr -> expr / expr .)
    :               reduce using rule 50 (expr -> expr / expr .)
    error           reduce using rule 50 (expr -> expr / expr .)
    {               reduce using rule 50 (expr -> expr / expr .)
    BREAK           reduce using rule 50 (expr -> expr / expr .)
    CONTINUE        reduce using rule 50 (expr -> expr / expr .)
    PRINT           reduce using rule 50 (expr -> expr / expr .)
    WHILE           reduce using rule 50 (expr -> expr / expr .)
    FOR             reduce using rule 50 (expr -> expr / expr .)
    RETURN          reduce using rule 50 (expr -> expr / expr .)
    IF              reduce using rule 50 (expr -> expr / expr .)
    ID              reduce using rule 50 (expr -> expr / expr .)


state 114

    (51) expr -> expr * expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 51 (expr -> expr * expr .)
    DOTSUB          reduce using rule 51 (expr -> expr * expr .)
    DOTADD          reduce using rule 51 (expr -> expr * expr .)
    DOTDIV          reduce using rule 51 (expr -> expr * expr .)
    DOTMUL          reduce using rule 51 (expr -> expr * expr .)
    OR              reduce using rule 51 (expr -> expr * expr .)
    AND             reduce using rule 51 (expr -> expr * expr .)
    XOR             reduce using rule 51 (expr -> expr * expr .)
    GREATEREQUAL    reduce using rule 51 (expr -> expr * expr .)
    LESSEREQUAL     reduce using rule 51 (expr -> expr * expr .)
    GREATER         reduce using rule 51 (expr -> expr * expr .)
    LESSER          reduce using rule 51 (expr -> expr * expr .)
    NOTEQUAL        reduce using rule 51 (expr -> expr * expr .)
    EQUAL           reduce using rule 51 (expr -> expr * expr .)
    /               reduce using rule 51 (expr -> expr * expr .)
    *               reduce using rule 51 (expr -> expr * expr .)
    -               reduce using rule 51 (expr -> expr * expr .)
    +               reduce using rule 51 (expr -> expr * expr .)
    '               reduce using rule 51 (expr -> expr * expr .)
    ;               reduce using rule 51 (expr -> expr * expr .)
    )               reduce using rule 51 (expr -> expr * expr .)
    ]               reduce using rule 51 (expr -> expr * expr .)
    :               reduce using rule 51 (expr -> expr * expr .)
    error           reduce using rule 51 (expr -> expr * expr .)
    {               reduce using rule 51 (expr -> expr * expr .)
    BREAK           reduce using rule 51 (expr -> expr * expr .)
    CONTINUE        reduce using rule 51 (expr -> expr * expr .)
    PRINT           reduce using rule 51 (expr -> expr * expr .)
    WHILE           reduce using rule 51 (expr -> expr * expr .)
    FOR             reduce using rule 51 (expr -> expr * expr .)
    RETURN          reduce using rule 51 (expr -> expr * expr .)
    IF              reduce using rule 51 (expr -> expr * expr .)
    ID              reduce using rule 51 (expr -> expr * expr .)


state 115

    (52) expr -> expr - expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 52 (expr -> expr - expr .)
    DOTSUB          reduce using rule 52 (expr -> expr - expr .)
    DOTADD          reduce using rule 52 (expr -> expr - expr .)
    OR              reduce using rule 52 (expr -> expr - expr .)
    AND             reduce using rule 52 (expr -> expr - expr .)
    XOR             reduce using rule 52 (expr -> expr - expr .)
    GREATEREQUAL    reduce using rule 52 (expr -> expr - expr .)
    LESSEREQUAL     reduce using rule 52 (expr -> expr - expr .)
    GREATER         reduce using rule 52 (expr -> expr - expr .)
    LESSER          reduce using rule 52 (expr -> expr - expr .)
    NOTEQUAL        reduce using rule 52 (expr -> expr - expr .)
    EQUAL           reduce using rule 52 (expr -> expr - expr .)
    -               reduce using rule 52 (expr -> expr - expr .)
    +               reduce using rule 52 (expr -> expr - expr .)
    '               reduce using rule 52 (expr -> expr - expr .)
    ;               reduce using rule 52 (expr -> expr - expr .)
    )               reduce using rule 52 (expr -> expr - expr .)
    ]               reduce using rule 52 (expr -> expr - expr .)
    :               reduce using rule 52 (expr -> expr - expr .)
    error           reduce using rule 52 (expr -> expr - expr .)
    {               reduce using rule 52 (expr -> expr - expr .)
    BREAK           reduce using rule 52 (expr -> expr - expr .)
    CONTINUE        reduce using rule 52 (expr -> expr - expr .)
    PRINT           reduce using rule 52 (expr -> expr - expr .)
    WHILE           reduce using rule 52 (expr -> expr - expr .)
    FOR             reduce using rule 52 (expr -> expr - expr .)
    RETURN          reduce using rule 52 (expr -> expr - expr .)
    IF              reduce using rule 52 (expr -> expr - expr .)
    ID              reduce using rule 52 (expr -> expr - expr .)
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    /               shift and go to state 71
    *               shift and go to state 72


state 116

    (53) expr -> expr + expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ,               reduce using rule 53 (expr -> expr + expr .)
    DOTSUB          reduce using rule 53 (expr -> expr + expr .)
    DOTADD          reduce using rule 53 (expr -> expr + expr .)
    OR              reduce using rule 53 (expr -> expr + expr .)
    AND             reduce using rule 53 (expr -> expr + expr .)
    XOR             reduce using rule 53 (expr -> expr + expr .)
    GREATEREQUAL    reduce using rule 53 (expr -> expr + expr .)
    LESSEREQUAL     reduce using rule 53 (expr -> expr + expr .)
    GREATER         reduce using rule 53 (expr -> expr + expr .)
    LESSER          reduce using rule 53 (expr -> expr + expr .)
    NOTEQUAL        reduce using rule 53 (expr -> expr + expr .)
    EQUAL           reduce using rule 53 (expr -> expr + expr .)
    -               reduce using rule 53 (expr -> expr + expr .)
    +               reduce using rule 53 (expr -> expr + expr .)
    '               reduce using rule 53 (expr -> expr + expr .)
    ;               reduce using rule 53 (expr -> expr + expr .)
    )               reduce using rule 53 (expr -> expr + expr .)
    ]               reduce using rule 53 (expr -> expr + expr .)
    :               reduce using rule 53 (expr -> expr + expr .)
    error           reduce using rule 53 (expr -> expr + expr .)
    {               reduce using rule 53 (expr -> expr + expr .)
    BREAK           reduce using rule 53 (expr -> expr + expr .)
    CONTINUE        reduce using rule 53 (expr -> expr + expr .)
    PRINT           reduce using rule 53 (expr -> expr + expr .)
    WHILE           reduce using rule 53 (expr -> expr + expr .)
    FOR             reduce using rule 53 (expr -> expr + expr .)
    RETURN          reduce using rule 53 (expr -> expr + expr .)
    IF              reduce using rule 53 (expr -> expr + expr .)
    ID              reduce using rule 53 (expr -> expr + expr .)
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    /               shift and go to state 71
    *               shift and go to state 72


state 117

    (34) expr -> mat_fun ( error . )
    )               shift and go to state 130


state 118

    (35) expr -> mat_fun ( mat_fun_args . )
    (80) mat_fun_args -> mat_fun_args . , expr
    )               shift and go to state 131
    ,               shift and go to state 127


state 119

    (55) expr -> ( expr ) .
    ,               reduce using rule 55 (expr -> ( expr ) .)
    DOTSUB          reduce using rule 55 (expr -> ( expr ) .)
    DOTADD          reduce using rule 55 (expr -> ( expr ) .)
    DOTDIV          reduce using rule 55 (expr -> ( expr ) .)
    DOTMUL          reduce using rule 55 (expr -> ( expr ) .)
    OR              reduce using rule 55 (expr -> ( expr ) .)
    AND             reduce using rule 55 (expr -> ( expr ) .)
    XOR             reduce using rule 55 (expr -> ( expr ) .)
    GREATEREQUAL    reduce using rule 55 (expr -> ( expr ) .)
    LESSEREQUAL     reduce using rule 55 (expr -> ( expr ) .)
    GREATER         reduce using rule 55 (expr -> ( expr ) .)
    LESSER          reduce using rule 55 (expr -> ( expr ) .)
    NOTEQUAL        reduce using rule 55 (expr -> ( expr ) .)
    EQUAL           reduce using rule 55 (expr -> ( expr ) .)
    /               reduce using rule 55 (expr -> ( expr ) .)
    *               reduce using rule 55 (expr -> ( expr ) .)
    -               reduce using rule 55 (expr -> ( expr ) .)
    +               reduce using rule 55 (expr -> ( expr ) .)
    '               reduce using rule 55 (expr -> ( expr ) .)
    ;               reduce using rule 55 (expr -> ( expr ) .)
    )               reduce using rule 55 (expr -> ( expr ) .)
    ]               reduce using rule 55 (expr -> ( expr ) .)
    :               reduce using rule 55 (expr -> ( expr ) .)
    error           reduce using rule 55 (expr -> ( expr ) .)
    {               reduce using rule 55 (expr -> ( expr ) .)
    BREAK           reduce using rule 55 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 55 (expr -> ( expr ) .)
    PRINT           reduce using rule 55 (expr -> ( expr ) .)
    WHILE           reduce using rule 55 (expr -> ( expr ) .)
    FOR             reduce using rule 55 (expr -> ( expr ) .)
    RETURN          reduce using rule 55 (expr -> ( expr ) .)
    IF              reduce using rule 55 (expr -> ( expr ) .)
    ID              reduce using rule 55 (expr -> ( expr ) .)


state 120

    (76) vector -> [ variables ] .
    ,               reduce using rule 76 (vector -> [ variables ] .)
    DOTSUB          reduce using rule 76 (vector -> [ variables ] .)
    DOTADD          reduce using rule 76 (vector -> [ variables ] .)
    DOTDIV          reduce using rule 76 (vector -> [ variables ] .)
    DOTMUL          reduce using rule 76 (vector -> [ variables ] .)
    OR              reduce using rule 76 (vector -> [ variables ] .)
    AND             reduce using rule 76 (vector -> [ variables ] .)
    XOR             reduce using rule 76 (vector -> [ variables ] .)
    GREATEREQUAL    reduce using rule 76 (vector -> [ variables ] .)
    LESSEREQUAL     reduce using rule 76 (vector -> [ variables ] .)
    GREATER         reduce using rule 76 (vector -> [ variables ] .)
    LESSER          reduce using rule 76 (vector -> [ variables ] .)
    NOTEQUAL        reduce using rule 76 (vector -> [ variables ] .)
    EQUAL           reduce using rule 76 (vector -> [ variables ] .)
    /               reduce using rule 76 (vector -> [ variables ] .)
    *               reduce using rule 76 (vector -> [ variables ] .)
    -               reduce using rule 76 (vector -> [ variables ] .)
    +               reduce using rule 76 (vector -> [ variables ] .)
    '               reduce using rule 76 (vector -> [ variables ] .)
    ;               reduce using rule 76 (vector -> [ variables ] .)
    )               reduce using rule 76 (vector -> [ variables ] .)
    ]               reduce using rule 76 (vector -> [ variables ] .)
    :               reduce using rule 76 (vector -> [ variables ] .)
    error           reduce using rule 76 (vector -> [ variables ] .)
    {               reduce using rule 76 (vector -> [ variables ] .)
    BREAK           reduce using rule 76 (vector -> [ variables ] .)
    CONTINUE        reduce using rule 76 (vector -> [ variables ] .)
    PRINT           reduce using rule 76 (vector -> [ variables ] .)
    WHILE           reduce using rule 76 (vector -> [ variables ] .)
    FOR             reduce using rule 76 (vector -> [ variables ] .)
    RETURN          reduce using rule 76 (vector -> [ variables ] .)
    IF              reduce using rule 76 (vector -> [ variables ] .)
    ID              reduce using rule 76 (vector -> [ variables ] .)


state 121

    (78) variables -> variables , . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 132
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 122

    (20) while_l -> WHILE ( expr ) . error
    (22) while_l -> WHILE ( expr ) . instruction
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 133
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instruction                    shift and go to state 134
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 123

    (21) while_l -> WHILE ( error ) . instruction
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instruction                    shift and go to state 135
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 124

    (23) for_l -> FOR ID = expr . : expr error
    (24) for_l -> FOR ID = expr . : error instruction
    (26) for_l -> FOR ID = expr . : expr instruction
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    :               shift and go to state 136
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 125

    (25) for_l -> FOR ID = error . : expr instruction
    :               shift and go to state 137


state 126

    (62) matel -> ID [ mat_fun_args ] .
    DIVASSIGN       reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    MULASSIGN       reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    SUBASSIGN       reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    ADDASSIGN       reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    =               reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    ,               reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    DOTSUB          reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    DOTADD          reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    DOTDIV          reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    DOTMUL          reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    OR              reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    AND             reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    XOR             reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    GREATEREQUAL    reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    LESSEREQUAL     reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    GREATER         reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    LESSER          reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    NOTEQUAL        reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    EQUAL           reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    /               reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    *               reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    -               reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    +               reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    '               reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    ;               reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    )               reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    ]               reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    :               reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    error           reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    {               reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    BREAK           reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    CONTINUE        reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    PRINT           reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    WHILE           reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    FOR             reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    RETURN          reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    IF              reduce using rule 62 (matel -> ID [ mat_fun_args ] .)
    ID              reduce using rule 62 (matel -> ID [ mat_fun_args ] .)


state 127

    (80) mat_fun_args -> mat_fun_args , . expr
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 138
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 128

    (13) if_i -> IF ( expr ) . instruction ELSE error
    (14) if_i -> IF ( expr ) . error ELSE instruction
    (15) if_i -> IF ( expr ) . error
    (18) if_i -> IF ( expr ) . instruction ELSE instruction
    (19) if_i -> IF ( expr ) . instruction
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 140
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instruction                    shift and go to state 139
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 129

    (16) if_i -> IF ( error ) . instruction ELSE instruction
    (17) if_i -> IF ( error ) . instruction
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instruction                    shift and go to state 141
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 130

    (34) expr -> mat_fun ( error ) .
    ,               reduce using rule 34 (expr -> mat_fun ( error ) .)
    DOTSUB          reduce using rule 34 (expr -> mat_fun ( error ) .)
    DOTADD          reduce using rule 34 (expr -> mat_fun ( error ) .)
    DOTDIV          reduce using rule 34 (expr -> mat_fun ( error ) .)
    DOTMUL          reduce using rule 34 (expr -> mat_fun ( error ) .)
    OR              reduce using rule 34 (expr -> mat_fun ( error ) .)
    AND             reduce using rule 34 (expr -> mat_fun ( error ) .)
    XOR             reduce using rule 34 (expr -> mat_fun ( error ) .)
    GREATEREQUAL    reduce using rule 34 (expr -> mat_fun ( error ) .)
    LESSEREQUAL     reduce using rule 34 (expr -> mat_fun ( error ) .)
    GREATER         reduce using rule 34 (expr -> mat_fun ( error ) .)
    LESSER          reduce using rule 34 (expr -> mat_fun ( error ) .)
    NOTEQUAL        reduce using rule 34 (expr -> mat_fun ( error ) .)
    EQUAL           reduce using rule 34 (expr -> mat_fun ( error ) .)
    /               reduce using rule 34 (expr -> mat_fun ( error ) .)
    *               reduce using rule 34 (expr -> mat_fun ( error ) .)
    -               reduce using rule 34 (expr -> mat_fun ( error ) .)
    +               reduce using rule 34 (expr -> mat_fun ( error ) .)
    '               reduce using rule 34 (expr -> mat_fun ( error ) .)
    ;               reduce using rule 34 (expr -> mat_fun ( error ) .)
    )               reduce using rule 34 (expr -> mat_fun ( error ) .)
    ]               reduce using rule 34 (expr -> mat_fun ( error ) .)
    :               reduce using rule 34 (expr -> mat_fun ( error ) .)
    error           reduce using rule 34 (expr -> mat_fun ( error ) .)
    {               reduce using rule 34 (expr -> mat_fun ( error ) .)
    BREAK           reduce using rule 34 (expr -> mat_fun ( error ) .)
    CONTINUE        reduce using rule 34 (expr -> mat_fun ( error ) .)
    PRINT           reduce using rule 34 (expr -> mat_fun ( error ) .)
    WHILE           reduce using rule 34 (expr -> mat_fun ( error ) .)
    FOR             reduce using rule 34 (expr -> mat_fun ( error ) .)
    RETURN          reduce using rule 34 (expr -> mat_fun ( error ) .)
    IF              reduce using rule 34 (expr -> mat_fun ( error ) .)
    ID              reduce using rule 34 (expr -> mat_fun ( error ) .)


state 131

    (35) expr -> mat_fun ( mat_fun_args ) .
    ,               reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    DOTSUB          reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    DOTADD          reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    DOTDIV          reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    DOTMUL          reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    OR              reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    AND             reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    XOR             reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    GREATEREQUAL    reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    LESSEREQUAL     reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    GREATER         reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    LESSER          reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    NOTEQUAL        reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    EQUAL           reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    /               reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    *               reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    -               reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    +               reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    '               reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    ;               reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    )               reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    ]               reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    :               reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    error           reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    {               reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    BREAK           reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    CONTINUE        reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    PRINT           reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    WHILE           reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    FOR             reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    RETURN          reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    IF              reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)
    ID              reduce using rule 35 (expr -> mat_fun ( mat_fun_args ) .)


state 132

    (78) variables -> variables , expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ]               reduce using rule 78 (variables -> variables , expr .)
    ,               reduce using rule 78 (variables -> variables , expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 133

    (20) while_l -> WHILE ( expr ) error .
    {               reduce using rule 20 (while_l -> WHILE ( expr ) error .)
    BREAK           reduce using rule 20 (while_l -> WHILE ( expr ) error .)
    CONTINUE        reduce using rule 20 (while_l -> WHILE ( expr ) error .)
    PRINT           reduce using rule 20 (while_l -> WHILE ( expr ) error .)
    WHILE           reduce using rule 20 (while_l -> WHILE ( expr ) error .)
    FOR             reduce using rule 20 (while_l -> WHILE ( expr ) error .)
    RETURN          reduce using rule 20 (while_l -> WHILE ( expr ) error .)
    IF              reduce using rule 20 (while_l -> WHILE ( expr ) error .)
    ID              reduce using rule 20 (while_l -> WHILE ( expr ) error .)
    $end            reduce using rule 20 (while_l -> WHILE ( expr ) error .)
    }               reduce using rule 20 (while_l -> WHILE ( expr ) error .)
    ELSE            reduce using rule 20 (while_l -> WHILE ( expr ) error .)


state 134

    (22) while_l -> WHILE ( expr ) instruction .
    {               reduce using rule 22 (while_l -> WHILE ( expr ) instruction .)
    BREAK           reduce using rule 22 (while_l -> WHILE ( expr ) instruction .)
    CONTINUE        reduce using rule 22 (while_l -> WHILE ( expr ) instruction .)
    PRINT           reduce using rule 22 (while_l -> WHILE ( expr ) instruction .)
    WHILE           reduce using rule 22 (while_l -> WHILE ( expr ) instruction .)
    FOR             reduce using rule 22 (while_l -> WHILE ( expr ) instruction .)
    RETURN          reduce using rule 22 (while_l -> WHILE ( expr ) instruction .)
    IF              reduce using rule 22 (while_l -> WHILE ( expr ) instruction .)
    ID              reduce using rule 22 (while_l -> WHILE ( expr ) instruction .)
    $end            reduce using rule 22 (while_l -> WHILE ( expr ) instruction .)
    }               reduce using rule 22 (while_l -> WHILE ( expr ) instruction .)
    ELSE            reduce using rule 22 (while_l -> WHILE ( expr ) instruction .)


state 135

    (21) while_l -> WHILE ( error ) instruction .
    {               reduce using rule 21 (while_l -> WHILE ( error ) instruction .)
    BREAK           reduce using rule 21 (while_l -> WHILE ( error ) instruction .)
    CONTINUE        reduce using rule 21 (while_l -> WHILE ( error ) instruction .)
    PRINT           reduce using rule 21 (while_l -> WHILE ( error ) instruction .)
    WHILE           reduce using rule 21 (while_l -> WHILE ( error ) instruction .)
    FOR             reduce using rule 21 (while_l -> WHILE ( error ) instruction .)
    RETURN          reduce using rule 21 (while_l -> WHILE ( error ) instruction .)
    IF              reduce using rule 21 (while_l -> WHILE ( error ) instruction .)
    ID              reduce using rule 21 (while_l -> WHILE ( error ) instruction .)
    $end            reduce using rule 21 (while_l -> WHILE ( error ) instruction .)
    }               reduce using rule 21 (while_l -> WHILE ( error ) instruction .)
    ELSE            reduce using rule 21 (while_l -> WHILE ( error ) instruction .)


state 136

    (23) for_l -> FOR ID = expr : . expr error
    (24) for_l -> FOR ID = expr : . error instruction
    (26) for_l -> FOR ID = expr : . expr instruction
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 143
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 142
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 137

    (25) for_l -> FOR ID = error : . expr instruction
    (34) expr -> . mat_fun ( error )
    (35) expr -> . mat_fun ( mat_fun_args )
    (36) expr -> . vector
    (37) expr -> . expr DOTSUB expr
    (38) expr -> . expr DOTADD expr
    (39) expr -> . expr DOTDIV expr
    (40) expr -> . expr DOTMUL expr
    (41) expr -> . expr OR expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr XOR expr
    (44) expr -> . expr GREATEREQUAL expr
    (45) expr -> . expr LESSEREQUAL expr
    (46) expr -> . expr GREATER expr
    (47) expr -> . expr LESSER expr
    (48) expr -> . expr NOTEQUAL expr
    (49) expr -> . expr EQUAL expr
    (50) expr -> . expr / expr
    (51) expr -> . expr * expr
    (52) expr -> . expr - expr
    (53) expr -> . expr + expr
    (54) expr -> . unary
    (55) expr -> . ( expr )
    (56) expr -> . var
    (57) expr -> . FLOATNUM
    (58) expr -> . INTNUM
    (59) expr -> . STRING
    (81) mat_fun -> . ONES
    (82) mat_fun -> . EYE
    (83) mat_fun -> . ZEROS
    (76) vector -> . [ variables ]
    (73) unary -> . expr '
    (74) unary -> . NOT expr
    (75) unary -> . - expr
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 32
    FLOATNUM        shift and go to state 37
    INTNUM          shift and go to state 38
    STRING          shift and go to state 39
    ONES            shift and go to state 40
    EYE             shift and go to state 41
    ZEROS           shift and go to state 42
    [               shift and go to state 43
    NOT             shift and go to state 44
    -               shift and go to state 34
    ID              shift and go to state 17

    expr                           shift and go to state 144
    mat_fun                        shift and go to state 31
    vector                         shift and go to state 33
    unary                          shift and go to state 35
    var                            shift and go to state 36
    matel                          shift and go to state 20

state 138

    (80) mat_fun_args -> mat_fun_args , expr .
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    ]               reduce using rule 80 (mat_fun_args -> mat_fun_args , expr .)
    ,               reduce using rule 80 (mat_fun_args -> mat_fun_args , expr .)
    )               reduce using rule 80 (mat_fun_args -> mat_fun_args , expr .)
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75


state 139

    (13) if_i -> IF ( expr ) instruction . ELSE error
    (18) if_i -> IF ( expr ) instruction . ELSE instruction
    (19) if_i -> IF ( expr ) instruction .
    ELSE            shift and go to state 145
    {               reduce using rule 19 (if_i -> IF ( expr ) instruction .)
    BREAK           reduce using rule 19 (if_i -> IF ( expr ) instruction .)
    CONTINUE        reduce using rule 19 (if_i -> IF ( expr ) instruction .)
    PRINT           reduce using rule 19 (if_i -> IF ( expr ) instruction .)
    WHILE           reduce using rule 19 (if_i -> IF ( expr ) instruction .)
    FOR             reduce using rule 19 (if_i -> IF ( expr ) instruction .)
    RETURN          reduce using rule 19 (if_i -> IF ( expr ) instruction .)
    IF              reduce using rule 19 (if_i -> IF ( expr ) instruction .)
    ID              reduce using rule 19 (if_i -> IF ( expr ) instruction .)
    $end            reduce using rule 19 (if_i -> IF ( expr ) instruction .)
    }               reduce using rule 19 (if_i -> IF ( expr ) instruction .)


state 140

    (14) if_i -> IF ( expr ) error . ELSE instruction
    (15) if_i -> IF ( expr ) error .
    ELSE            shift and go to state 146
    {               reduce using rule 15 (if_i -> IF ( expr ) error .)
    BREAK           reduce using rule 15 (if_i -> IF ( expr ) error .)
    CONTINUE        reduce using rule 15 (if_i -> IF ( expr ) error .)
    PRINT           reduce using rule 15 (if_i -> IF ( expr ) error .)
    WHILE           reduce using rule 15 (if_i -> IF ( expr ) error .)
    FOR             reduce using rule 15 (if_i -> IF ( expr ) error .)
    RETURN          reduce using rule 15 (if_i -> IF ( expr ) error .)
    IF              reduce using rule 15 (if_i -> IF ( expr ) error .)
    ID              reduce using rule 15 (if_i -> IF ( expr ) error .)
    $end            reduce using rule 15 (if_i -> IF ( expr ) error .)
    }               reduce using rule 15 (if_i -> IF ( expr ) error .)


state 141

    (16) if_i -> IF ( error ) instruction . ELSE instruction
    (17) if_i -> IF ( error ) instruction .
    ELSE            shift and go to state 147
    {               reduce using rule 17 (if_i -> IF ( error ) instruction .)
    BREAK           reduce using rule 17 (if_i -> IF ( error ) instruction .)
    CONTINUE        reduce using rule 17 (if_i -> IF ( error ) instruction .)
    PRINT           reduce using rule 17 (if_i -> IF ( error ) instruction .)
    WHILE           reduce using rule 17 (if_i -> IF ( error ) instruction .)
    FOR             reduce using rule 17 (if_i -> IF ( error ) instruction .)
    RETURN          reduce using rule 17 (if_i -> IF ( error ) instruction .)
    IF              reduce using rule 17 (if_i -> IF ( error ) instruction .)
    ID              reduce using rule 17 (if_i -> IF ( error ) instruction .)
    $end            reduce using rule 17 (if_i -> IF ( error ) instruction .)
    }               reduce using rule 17 (if_i -> IF ( error ) instruction .)


state 142

    (23) for_l -> FOR ID = expr : expr . error
    (26) for_l -> FOR ID = expr : expr . instruction
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 148
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instruction                    shift and go to state 149
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 143

    (24) for_l -> FOR ID = expr : error . instruction
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instruction                    shift and go to state 150
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 144

    (25) for_l -> FOR ID = error : expr . instruction
    (37) expr -> expr . DOTSUB expr
    (38) expr -> expr . DOTADD expr
    (39) expr -> expr . DOTDIV expr
    (40) expr -> expr . DOTMUL expr
    (41) expr -> expr . OR expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . XOR expr
    (44) expr -> expr . GREATEREQUAL expr
    (45) expr -> expr . LESSEREQUAL expr
    (46) expr -> expr . GREATER expr
    (47) expr -> expr . LESSER expr
    (48) expr -> expr . NOTEQUAL expr
    (49) expr -> expr . EQUAL expr
    (50) expr -> expr . / expr
    (51) expr -> expr . * expr
    (52) expr -> expr . - expr
    (53) expr -> expr . + expr
    (73) unary -> expr . '
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    DOTSUB          shift and go to state 58
    DOTADD          shift and go to state 59
    DOTDIV          shift and go to state 60
    DOTMUL          shift and go to state 61
    OR              shift and go to state 62
    AND             shift and go to state 63
    XOR             shift and go to state 64
    GREATEREQUAL    shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATER         shift and go to state 67
    LESSER          shift and go to state 68
    NOTEQUAL        shift and go to state 69
    EQUAL           shift and go to state 70
    /               shift and go to state 71
    *               shift and go to state 72
    -               shift and go to state 73
    +               shift and go to state 74
    '               shift and go to state 75
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instruction                    shift and go to state 151
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 145

    (13) if_i -> IF ( expr ) instruction ELSE . error
    (18) if_i -> IF ( expr ) instruction ELSE . instruction
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 153
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instruction                    shift and go to state 152
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 146

    (14) if_i -> IF ( expr ) error ELSE . instruction
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instruction                    shift and go to state 154
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 147

    (16) if_i -> IF ( error ) instruction ELSE . instruction
    (4) instruction -> . { instructions }
    (5) instruction -> . BREAK ;
    (6) instruction -> . CONTINUE ;
    (7) instruction -> . print_i ;
    (8) instruction -> . assign ;
    (9) instruction -> . while_l
    (10) instruction -> . for_l
    (11) instruction -> . return_i ;
    (12) instruction -> . if_i
    (30) print_i -> . PRINT error
    (31) print_i -> . PRINT printargs
    (63) assign -> . var DIVASSIGN error
    (64) assign -> . var MULASSIGN error
    (65) assign -> . var SUBASSIGN error
    (66) assign -> . var ADDASSIGN error
    (67) assign -> . var = error
    (68) assign -> . var DIVASSIGN expr
    (69) assign -> . var MULASSIGN expr
    (70) assign -> . var SUBASSIGN expr
    (71) assign -> . var ADDASSIGN expr
    (72) assign -> . var = expr
    (20) while_l -> . WHILE ( expr ) error
    (21) while_l -> . WHILE ( error ) instruction
    (22) while_l -> . WHILE ( expr ) instruction
    (23) for_l -> . FOR ID = expr : expr error
    (24) for_l -> . FOR ID = expr : error instruction
    (25) for_l -> . FOR ID = error : expr instruction
    (26) for_l -> . FOR ID = expr : expr instruction
    (27) return_i -> . RETURN error
    (28) return_i -> . RETURN expr
    (29) return_i -> . RETURN
    (13) if_i -> . IF ( expr ) instruction ELSE error
    (14) if_i -> . IF ( expr ) error ELSE instruction
    (15) if_i -> . IF ( expr ) error
    (16) if_i -> . IF ( error ) instruction ELSE instruction
    (17) if_i -> . IF ( error ) instruction
    (18) if_i -> . IF ( expr ) instruction ELSE instruction
    (19) if_i -> . IF ( expr ) instruction
    (60) var -> . ID
    (61) var -> . matel
    (62) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 4
    BREAK           shift and go to state 5
    CONTINUE        shift and go to state 6
    PRINT           shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 17

    instruction                    shift and go to state 155
    print_i                        shift and go to state 7
    assign                         shift and go to state 8
    while_l                        shift and go to state 9
    for_l                          shift and go to state 10
    return_i                       shift and go to state 11
    if_i                           shift and go to state 12
    var                            shift and go to state 14
    matel                          shift and go to state 20

state 148

    (23) for_l -> FOR ID = expr : expr error .
    {               reduce using rule 23 (for_l -> FOR ID = expr : expr error .)
    BREAK           reduce using rule 23 (for_l -> FOR ID = expr : expr error .)
    CONTINUE        reduce using rule 23 (for_l -> FOR ID = expr : expr error .)
    PRINT           reduce using rule 23 (for_l -> FOR ID = expr : expr error .)
    WHILE           reduce using rule 23 (for_l -> FOR ID = expr : expr error .)
    FOR             reduce using rule 23 (for_l -> FOR ID = expr : expr error .)
    RETURN          reduce using rule 23 (for_l -> FOR ID = expr : expr error .)
    IF              reduce using rule 23 (for_l -> FOR ID = expr : expr error .)
    ID              reduce using rule 23 (for_l -> FOR ID = expr : expr error .)
    $end            reduce using rule 23 (for_l -> FOR ID = expr : expr error .)
    }               reduce using rule 23 (for_l -> FOR ID = expr : expr error .)
    ELSE            reduce using rule 23 (for_l -> FOR ID = expr : expr error .)


state 149

    (26) for_l -> FOR ID = expr : expr instruction .
    {               reduce using rule 26 (for_l -> FOR ID = expr : expr instruction .)
    BREAK           reduce using rule 26 (for_l -> FOR ID = expr : expr instruction .)
    CONTINUE        reduce using rule 26 (for_l -> FOR ID = expr : expr instruction .)
    PRINT           reduce using rule 26 (for_l -> FOR ID = expr : expr instruction .)
    WHILE           reduce using rule 26 (for_l -> FOR ID = expr : expr instruction .)
    FOR             reduce using rule 26 (for_l -> FOR ID = expr : expr instruction .)
    RETURN          reduce using rule 26 (for_l -> FOR ID = expr : expr instruction .)
    IF              reduce using rule 26 (for_l -> FOR ID = expr : expr instruction .)
    ID              reduce using rule 26 (for_l -> FOR ID = expr : expr instruction .)
    $end            reduce using rule 26 (for_l -> FOR ID = expr : expr instruction .)
    }               reduce using rule 26 (for_l -> FOR ID = expr : expr instruction .)
    ELSE            reduce using rule 26 (for_l -> FOR ID = expr : expr instruction .)


state 150

    (24) for_l -> FOR ID = expr : error instruction .
    {               reduce using rule 24 (for_l -> FOR ID = expr : error instruction .)
    BREAK           reduce using rule 24 (for_l -> FOR ID = expr : error instruction .)
    CONTINUE        reduce using rule 24 (for_l -> FOR ID = expr : error instruction .)
    PRINT           reduce using rule 24 (for_l -> FOR ID = expr : error instruction .)
    WHILE           reduce using rule 24 (for_l -> FOR ID = expr : error instruction .)
    FOR             reduce using rule 24 (for_l -> FOR ID = expr : error instruction .)
    RETURN          reduce using rule 24 (for_l -> FOR ID = expr : error instruction .)
    IF              reduce using rule 24 (for_l -> FOR ID = expr : error instruction .)
    ID              reduce using rule 24 (for_l -> FOR ID = expr : error instruction .)
    $end            reduce using rule 24 (for_l -> FOR ID = expr : error instruction .)
    }               reduce using rule 24 (for_l -> FOR ID = expr : error instruction .)
    ELSE            reduce using rule 24 (for_l -> FOR ID = expr : error instruction .)


state 151

    (25) for_l -> FOR ID = error : expr instruction .
    {               reduce using rule 25 (for_l -> FOR ID = error : expr instruction .)
    BREAK           reduce using rule 25 (for_l -> FOR ID = error : expr instruction .)
    CONTINUE        reduce using rule 25 (for_l -> FOR ID = error : expr instruction .)
    PRINT           reduce using rule 25 (for_l -> FOR ID = error : expr instruction .)
    WHILE           reduce using rule 25 (for_l -> FOR ID = error : expr instruction .)
    FOR             reduce using rule 25 (for_l -> FOR ID = error : expr instruction .)
    RETURN          reduce using rule 25 (for_l -> FOR ID = error : expr instruction .)
    IF              reduce using rule 25 (for_l -> FOR ID = error : expr instruction .)
    ID              reduce using rule 25 (for_l -> FOR ID = error : expr instruction .)
    $end            reduce using rule 25 (for_l -> FOR ID = error : expr instruction .)
    }               reduce using rule 25 (for_l -> FOR ID = error : expr instruction .)
    ELSE            reduce using rule 25 (for_l -> FOR ID = error : expr instruction .)


state 152

    (18) if_i -> IF ( expr ) instruction ELSE instruction .
    {               reduce using rule 18 (if_i -> IF ( expr ) instruction ELSE instruction .)
    BREAK           reduce using rule 18 (if_i -> IF ( expr ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 18 (if_i -> IF ( expr ) instruction ELSE instruction .)
    PRINT           reduce using rule 18 (if_i -> IF ( expr ) instruction ELSE instruction .)
    WHILE           reduce using rule 18 (if_i -> IF ( expr ) instruction ELSE instruction .)
    FOR             reduce using rule 18 (if_i -> IF ( expr ) instruction ELSE instruction .)
    RETURN          reduce using rule 18 (if_i -> IF ( expr ) instruction ELSE instruction .)
    IF              reduce using rule 18 (if_i -> IF ( expr ) instruction ELSE instruction .)
    ID              reduce using rule 18 (if_i -> IF ( expr ) instruction ELSE instruction .)
    $end            reduce using rule 18 (if_i -> IF ( expr ) instruction ELSE instruction .)
    }               reduce using rule 18 (if_i -> IF ( expr ) instruction ELSE instruction .)
    ELSE            reduce using rule 18 (if_i -> IF ( expr ) instruction ELSE instruction .)


state 153

    (13) if_i -> IF ( expr ) instruction ELSE error .
    {               reduce using rule 13 (if_i -> IF ( expr ) instruction ELSE error .)
    BREAK           reduce using rule 13 (if_i -> IF ( expr ) instruction ELSE error .)
    CONTINUE        reduce using rule 13 (if_i -> IF ( expr ) instruction ELSE error .)
    PRINT           reduce using rule 13 (if_i -> IF ( expr ) instruction ELSE error .)
    WHILE           reduce using rule 13 (if_i -> IF ( expr ) instruction ELSE error .)
    FOR             reduce using rule 13 (if_i -> IF ( expr ) instruction ELSE error .)
    RETURN          reduce using rule 13 (if_i -> IF ( expr ) instruction ELSE error .)
    IF              reduce using rule 13 (if_i -> IF ( expr ) instruction ELSE error .)
    ID              reduce using rule 13 (if_i -> IF ( expr ) instruction ELSE error .)
    $end            reduce using rule 13 (if_i -> IF ( expr ) instruction ELSE error .)
    }               reduce using rule 13 (if_i -> IF ( expr ) instruction ELSE error .)
    ELSE            reduce using rule 13 (if_i -> IF ( expr ) instruction ELSE error .)


state 154

    (14) if_i -> IF ( expr ) error ELSE instruction .
    {               reduce using rule 14 (if_i -> IF ( expr ) error ELSE instruction .)
    BREAK           reduce using rule 14 (if_i -> IF ( expr ) error ELSE instruction .)
    CONTINUE        reduce using rule 14 (if_i -> IF ( expr ) error ELSE instruction .)
    PRINT           reduce using rule 14 (if_i -> IF ( expr ) error ELSE instruction .)
    WHILE           reduce using rule 14 (if_i -> IF ( expr ) error ELSE instruction .)
    FOR             reduce using rule 14 (if_i -> IF ( expr ) error ELSE instruction .)
    RETURN          reduce using rule 14 (if_i -> IF ( expr ) error ELSE instruction .)
    IF              reduce using rule 14 (if_i -> IF ( expr ) error ELSE instruction .)
    ID              reduce using rule 14 (if_i -> IF ( expr ) error ELSE instruction .)
    $end            reduce using rule 14 (if_i -> IF ( expr ) error ELSE instruction .)
    }               reduce using rule 14 (if_i -> IF ( expr ) error ELSE instruction .)
    ELSE            reduce using rule 14 (if_i -> IF ( expr ) error ELSE instruction .)


state 155

    (16) if_i -> IF ( error ) instruction ELSE instruction .
    {               reduce using rule 16 (if_i -> IF ( error ) instruction ELSE instruction .)
    BREAK           reduce using rule 16 (if_i -> IF ( error ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 16 (if_i -> IF ( error ) instruction ELSE instruction .)
    PRINT           reduce using rule 16 (if_i -> IF ( error ) instruction ELSE instruction .)
    WHILE           reduce using rule 16 (if_i -> IF ( error ) instruction ELSE instruction .)
    FOR             reduce using rule 16 (if_i -> IF ( error ) instruction ELSE instruction .)
    RETURN          reduce using rule 16 (if_i -> IF ( error ) instruction ELSE instruction .)
    IF              reduce using rule 16 (if_i -> IF ( error ) instruction ELSE instruction .)
    ID              reduce using rule 16 (if_i -> IF ( error ) instruction ELSE instruction .)
    $end            reduce using rule 16 (if_i -> IF ( error ) instruction ELSE instruction .)
    }               reduce using rule 16 (if_i -> IF ( error ) instruction ELSE instruction .)
    ELSE            reduce using rule 16 (if_i -> IF ( error ) instruction ELSE instruction .)
