Grammar:

Rule 0     S' -> program
Rule 1     program -> instructions_or_empty
Rule 2     instructions_or_empty -> <empty>
Rule 3     instructions_or_empty -> instructions
Rule 4     instructions -> instruction
Rule 5     instructions -> instructions instruction
Rule 6     instruction -> { instructions }
Rule 7     instruction -> BREAK ;
Rule 8     instruction -> CONTINUE ;
Rule 9     instruction -> print_i ;
Rule 10    instruction -> assign ;
Rule 11    instruction -> while_l
Rule 12    instruction -> for_l
Rule 13    instruction -> return_i ;
Rule 14    instruction -> if_i
Rule 15    if_i -> IF ( expr ) instruction ELSE error
Rule 16    if_i -> IF ( expr ) error ELSE instruction  [precedence=right, level=2]
Rule 17    if_i -> IF ( expr ) error  [precedence=right, level=1]
Rule 18    if_i -> IF ( error ) instruction ELSE instruction  [precedence=right, level=2]
Rule 19    if_i -> IF ( error ) instruction  [precedence=right, level=1]
Rule 20    if_i -> IF ( expr ) instruction ELSE instruction  [precedence=right, level=2]
Rule 21    if_i -> IF ( expr ) instruction  [precedence=right, level=1]
Rule 22    while_l -> WHILE ( expr ) error
Rule 23    while_l -> WHILE ( error ) instruction
Rule 24    while_l -> WHILE ( expr ) instruction
Rule 25    for_l -> FOR ID = expr : expr error
Rule 26    for_l -> FOR ID = expr : error instruction
Rule 27    for_l -> FOR ID = error : expr instruction
Rule 28    for_l -> FOR ID = expr : expr instruction
Rule 29    return_i -> RETURN error
Rule 30    return_i -> RETURN expr
Rule 31    return_i -> RETURN
Rule 32    print_i -> PRINT error
Rule 33    print_i -> PRINT printargs
Rule 34    printargs -> expr
Rule 35    printargs -> expr , printargs
Rule 36    expr -> mat_fun ( error )
Rule 37    expr -> mat_fun ( mat_fun_args )
Rule 38    expr -> vector
Rule 39    expr -> expr DOTSUB expr  [precedence=left, level=5]
Rule 40    expr -> expr DOTADD expr  [precedence=left, level=5]
Rule 41    expr -> expr DOTDIV expr  [precedence=left, level=6]
Rule 42    expr -> expr DOTMUL expr  [precedence=left, level=6]
Rule 43    expr -> expr OR expr  [precedence=left, level=4]
Rule 44    expr -> expr AND expr  [precedence=left, level=4]
Rule 45    expr -> expr XOR expr  [precedence=left, level=4]
Rule 46    expr -> expr GREATEREQUAL expr  [precedence=nonassoc, level=3]
Rule 47    expr -> expr LESSEREQUAL expr  [precedence=nonassoc, level=3]
Rule 48    expr -> expr GREATER expr  [precedence=nonassoc, level=3]
Rule 49    expr -> expr LESSER expr  [precedence=nonassoc, level=3]
Rule 50    expr -> expr NOTEQUAL expr  [precedence=nonassoc, level=3]
Rule 51    expr -> expr EQUAL expr  [precedence=nonassoc, level=3]
Rule 52    expr -> expr / expr  [precedence=left, level=6]
Rule 53    expr -> expr * expr  [precedence=left, level=6]
Rule 54    expr -> expr - expr  [precedence=left, level=5]
Rule 55    expr -> expr + expr  [precedence=left, level=5]
Rule 56    expr -> unary
Rule 57    expr -> ( expr )
Rule 58    expr -> var
Rule 59    expr -> FLOATNUM
Rule 60    expr -> INTNUM
Rule 61    expr -> STRING
Rule 62    var -> ID
Rule 63    var -> matel
Rule 64    matel -> ID [ mat_fun_args ]
Rule 65    assign -> var DIVASSIGN error
Rule 66    assign -> var MULASSIGN error
Rule 67    assign -> var SUBASSIGN error
Rule 68    assign -> var ADDASSIGN error
Rule 69    assign -> var = error
Rule 70    assign -> var DIVASSIGN expr
Rule 71    assign -> var MULASSIGN expr
Rule 72    assign -> var SUBASSIGN expr
Rule 73    assign -> var ADDASSIGN expr
Rule 74    assign -> var = expr
Rule 75    unary -> expr '
Rule 76    unary -> NOT expr  [precedence=right, level=7]
Rule 77    unary -> - expr  [precedence=right, level=7]
Rule 78    vector -> [ variables ]
Rule 79    variables -> expr
Rule 80    variables -> variables , expr
Rule 81    mat_fun_args -> expr
Rule 82    mat_fun_args -> mat_fun_args , expr
Rule 83    mat_fun -> ONES
Rule 84    mat_fun -> EYE
Rule 85    mat_fun -> ZEROS

Terminals, with rules where they appear:

'                    : 75
(                    : 15 16 17 18 19 20 21 22 23 24 36 37 57
)                    : 15 16 17 18 19 20 21 22 23 24 36 37 57
*                    : 53
+                    : 55
,                    : 35 80 82
-                    : 54 77
/                    : 52
:                    : 25 26 27 28
;                    : 7 8 9 10 13
=                    : 25 26 27 28 69 74
ADDASSIGN            : 68 73
AND                  : 44
BREAK                : 7
CONTINUE             : 8
DIVASSIGN            : 65 70
DOTADD               : 40
DOTDIV               : 41
DOTMUL               : 42
DOTSUB               : 39
ELSE                 : 15 16 18 20
EQUAL                : 51
EYE                  : 84
FLOATNUM             : 59
FOR                  : 25 26 27 28
GREATER              : 48
GREATEREQUAL         : 46
ID                   : 25 26 27 28 62 64
IF                   : 15 16 17 18 19 20 21
INTNUM               : 60
LESSER               : 49
LESSEREQUAL          : 47
MULASSIGN            : 66 71
NOT                  : 76
NOTEQUAL             : 50
ONES                 : 83
OR                   : 43
PRINT                : 32 33
RETURN               : 29 30 31
STRING               : 61
SUBASSIGN            : 67 72
WHILE                : 22 23 24
XOR                  : 45
ZEROS                : 85
[                    : 64 78
]                    : 64 78
error                : 15 16 17 18 19 22 23 25 26 27 29 32 36 65 66 67 68 69
{                    : 6
}                    : 6

Nonterminals, with rules where they appear:

assign               : 10
expr                 : 15 16 17 20 21 22 24 25 25 26 27 28 28 30 34 35 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 57 70 71 72 73 74 75 76 77 79 80 81 82
for_l                : 12
if_i                 : 14
instruction          : 4 5 15 16 18 18 19 20 20 21 23 24 26 27 28
instructions         : 3 5 6
instructions_or_empty : 1
mat_fun              : 36 37
mat_fun_args         : 37 64 82
matel                : 63
print_i              : 9
printargs            : 33 35
program              : 0
return_i             : 13
unary                : 56
var                  : 58 65 66 67 68 69 70 71 72 73 74
variables            : 78 80
vector               : 38
while_l              : 11


state 0

    (0) S' -> . program
    (1) program -> . instructions_or_empty
    (2) instructions_or_empty -> .
    (3) instructions_or_empty -> . instructions
    (4) instructions -> . instruction
    (5) instructions -> . instructions instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    $end            reduce using rule 2 (instructions_or_empty -> .)
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    program                        shift and go to state 1
    instructions_or_empty          shift and go to state 2
    instructions                   shift and go to state 3
    instruction                    shift and go to state 4
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 1

    (0) S' -> program .


state 2

    (1) program -> instructions_or_empty .
    $end            reduce using rule 1 (program -> instructions_or_empty .)


state 3

    (3) instructions_or_empty -> instructions .
    (5) instructions -> instructions . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    $end            reduce using rule 3 (instructions_or_empty -> instructions .)
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 22
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 4

    (4) instructions -> instruction .
    {               reduce using rule 4 (instructions -> instruction .)
    BREAK           reduce using rule 4 (instructions -> instruction .)
    CONTINUE        reduce using rule 4 (instructions -> instruction .)
    PRINT           reduce using rule 4 (instructions -> instruction .)
    WHILE           reduce using rule 4 (instructions -> instruction .)
    FOR             reduce using rule 4 (instructions -> instruction .)
    RETURN          reduce using rule 4 (instructions -> instruction .)
    IF              reduce using rule 4 (instructions -> instruction .)
    ID              reduce using rule 4 (instructions -> instruction .)
    $end            reduce using rule 4 (instructions -> instruction .)
    }               reduce using rule 4 (instructions -> instruction .)


state 5

    (6) instruction -> { . instructions }
    (4) instructions -> . instruction
    (5) instructions -> . instructions instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instructions                   shift and go to state 23
    instruction                    shift and go to state 4
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 6

    (7) instruction -> BREAK . ;
    ;               shift and go to state 24


state 7

    (8) instruction -> CONTINUE . ;
    ;               shift and go to state 25


state 8

    (9) instruction -> print_i . ;
    ;               shift and go to state 26


state 9

    (10) instruction -> assign . ;
    ;               shift and go to state 27


state 10

    (11) instruction -> while_l .
    {               reduce using rule 11 (instruction -> while_l .)
    BREAK           reduce using rule 11 (instruction -> while_l .)
    CONTINUE        reduce using rule 11 (instruction -> while_l .)
    PRINT           reduce using rule 11 (instruction -> while_l .)
    WHILE           reduce using rule 11 (instruction -> while_l .)
    FOR             reduce using rule 11 (instruction -> while_l .)
    RETURN          reduce using rule 11 (instruction -> while_l .)
    IF              reduce using rule 11 (instruction -> while_l .)
    ID              reduce using rule 11 (instruction -> while_l .)
    $end            reduce using rule 11 (instruction -> while_l .)
    }               reduce using rule 11 (instruction -> while_l .)
    ELSE            reduce using rule 11 (instruction -> while_l .)


state 11

    (12) instruction -> for_l .
    {               reduce using rule 12 (instruction -> for_l .)
    BREAK           reduce using rule 12 (instruction -> for_l .)
    CONTINUE        reduce using rule 12 (instruction -> for_l .)
    PRINT           reduce using rule 12 (instruction -> for_l .)
    WHILE           reduce using rule 12 (instruction -> for_l .)
    FOR             reduce using rule 12 (instruction -> for_l .)
    RETURN          reduce using rule 12 (instruction -> for_l .)
    IF              reduce using rule 12 (instruction -> for_l .)
    ID              reduce using rule 12 (instruction -> for_l .)
    $end            reduce using rule 12 (instruction -> for_l .)
    }               reduce using rule 12 (instruction -> for_l .)
    ELSE            reduce using rule 12 (instruction -> for_l .)


state 12

    (13) instruction -> return_i . ;
    ;               shift and go to state 28


state 13

    (14) instruction -> if_i .
    {               reduce using rule 14 (instruction -> if_i .)
    BREAK           reduce using rule 14 (instruction -> if_i .)
    CONTINUE        reduce using rule 14 (instruction -> if_i .)
    PRINT           reduce using rule 14 (instruction -> if_i .)
    WHILE           reduce using rule 14 (instruction -> if_i .)
    FOR             reduce using rule 14 (instruction -> if_i .)
    RETURN          reduce using rule 14 (instruction -> if_i .)
    IF              reduce using rule 14 (instruction -> if_i .)
    ID              reduce using rule 14 (instruction -> if_i .)
    $end            reduce using rule 14 (instruction -> if_i .)
    }               reduce using rule 14 (instruction -> if_i .)
    ELSE            reduce using rule 14 (instruction -> if_i .)


state 14

    (32) print_i -> PRINT . error
    (33) print_i -> PRINT . printargs
    (34) printargs -> . expr
    (35) printargs -> . expr , printargs
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 29
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    printargs                      shift and go to state 30
    expr                           shift and go to state 31
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 15

    (65) assign -> var . DIVASSIGN error
    (66) assign -> var . MULASSIGN error
    (67) assign -> var . SUBASSIGN error
    (68) assign -> var . ADDASSIGN error
    (69) assign -> var . = error
    (70) assign -> var . DIVASSIGN expr
    (71) assign -> var . MULASSIGN expr
    (72) assign -> var . SUBASSIGN expr
    (73) assign -> var . ADDASSIGN expr
    (74) assign -> var . = expr
    DIVASSIGN       shift and go to state 46
    MULASSIGN       shift and go to state 47
    SUBASSIGN       shift and go to state 48
    ADDASSIGN       shift and go to state 49
    =               shift and go to state 50


state 16

    (22) while_l -> WHILE . ( expr ) error
    (23) while_l -> WHILE . ( error ) instruction
    (24) while_l -> WHILE . ( expr ) instruction
    (               shift and go to state 51


state 17

    (25) for_l -> FOR . ID = expr : expr error
    (26) for_l -> FOR . ID = expr : error instruction
    (27) for_l -> FOR . ID = error : expr instruction
    (28) for_l -> FOR . ID = expr : expr instruction
    ID              shift and go to state 52


state 18

    (62) var -> ID .
    (64) matel -> ID . [ mat_fun_args ]
    DIVASSIGN       reduce using rule 62 (var -> ID .)
    MULASSIGN       reduce using rule 62 (var -> ID .)
    SUBASSIGN       reduce using rule 62 (var -> ID .)
    ADDASSIGN       reduce using rule 62 (var -> ID .)
    =               reduce using rule 62 (var -> ID .)
    ,               reduce using rule 62 (var -> ID .)
    DOTSUB          reduce using rule 62 (var -> ID .)
    DOTADD          reduce using rule 62 (var -> ID .)
    DOTDIV          reduce using rule 62 (var -> ID .)
    DOTMUL          reduce using rule 62 (var -> ID .)
    OR              reduce using rule 62 (var -> ID .)
    AND             reduce using rule 62 (var -> ID .)
    XOR             reduce using rule 62 (var -> ID .)
    GREATEREQUAL    reduce using rule 62 (var -> ID .)
    LESSEREQUAL     reduce using rule 62 (var -> ID .)
    GREATER         reduce using rule 62 (var -> ID .)
    LESSER          reduce using rule 62 (var -> ID .)
    NOTEQUAL        reduce using rule 62 (var -> ID .)
    EQUAL           reduce using rule 62 (var -> ID .)
    /               reduce using rule 62 (var -> ID .)
    *               reduce using rule 62 (var -> ID .)
    -               reduce using rule 62 (var -> ID .)
    +               reduce using rule 62 (var -> ID .)
    '               reduce using rule 62 (var -> ID .)
    ;               reduce using rule 62 (var -> ID .)
    )               reduce using rule 62 (var -> ID .)
    ]               reduce using rule 62 (var -> ID .)
    :               reduce using rule 62 (var -> ID .)
    error           reduce using rule 62 (var -> ID .)
    {               reduce using rule 62 (var -> ID .)
    BREAK           reduce using rule 62 (var -> ID .)
    CONTINUE        reduce using rule 62 (var -> ID .)
    PRINT           reduce using rule 62 (var -> ID .)
    WHILE           reduce using rule 62 (var -> ID .)
    FOR             reduce using rule 62 (var -> ID .)
    RETURN          reduce using rule 62 (var -> ID .)
    IF              reduce using rule 62 (var -> ID .)
    ID              reduce using rule 62 (var -> ID .)
    [               shift and go to state 53


state 19

    (29) return_i -> RETURN . error
    (30) return_i -> RETURN . expr
    (31) return_i -> RETURN .
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 54
    ;               reduce using rule 31 (return_i -> RETURN .)
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 55
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 20

    (15) if_i -> IF . ( expr ) instruction ELSE error
    (16) if_i -> IF . ( expr ) error ELSE instruction
    (17) if_i -> IF . ( expr ) error
    (18) if_i -> IF . ( error ) instruction ELSE instruction
    (19) if_i -> IF . ( error ) instruction
    (20) if_i -> IF . ( expr ) instruction ELSE instruction
    (21) if_i -> IF . ( expr ) instruction
    (               shift and go to state 56


state 21

    (63) var -> matel .
    DIVASSIGN       reduce using rule 63 (var -> matel .)
    MULASSIGN       reduce using rule 63 (var -> matel .)
    SUBASSIGN       reduce using rule 63 (var -> matel .)
    ADDASSIGN       reduce using rule 63 (var -> matel .)
    =               reduce using rule 63 (var -> matel .)
    ,               reduce using rule 63 (var -> matel .)
    DOTSUB          reduce using rule 63 (var -> matel .)
    DOTADD          reduce using rule 63 (var -> matel .)
    DOTDIV          reduce using rule 63 (var -> matel .)
    DOTMUL          reduce using rule 63 (var -> matel .)
    OR              reduce using rule 63 (var -> matel .)
    AND             reduce using rule 63 (var -> matel .)
    XOR             reduce using rule 63 (var -> matel .)
    GREATEREQUAL    reduce using rule 63 (var -> matel .)
    LESSEREQUAL     reduce using rule 63 (var -> matel .)
    GREATER         reduce using rule 63 (var -> matel .)
    LESSER          reduce using rule 63 (var -> matel .)
    NOTEQUAL        reduce using rule 63 (var -> matel .)
    EQUAL           reduce using rule 63 (var -> matel .)
    /               reduce using rule 63 (var -> matel .)
    *               reduce using rule 63 (var -> matel .)
    -               reduce using rule 63 (var -> matel .)
    +               reduce using rule 63 (var -> matel .)
    '               reduce using rule 63 (var -> matel .)
    ;               reduce using rule 63 (var -> matel .)
    )               reduce using rule 63 (var -> matel .)
    ]               reduce using rule 63 (var -> matel .)
    :               reduce using rule 63 (var -> matel .)
    error           reduce using rule 63 (var -> matel .)
    {               reduce using rule 63 (var -> matel .)
    BREAK           reduce using rule 63 (var -> matel .)
    CONTINUE        reduce using rule 63 (var -> matel .)
    PRINT           reduce using rule 63 (var -> matel .)
    WHILE           reduce using rule 63 (var -> matel .)
    FOR             reduce using rule 63 (var -> matel .)
    RETURN          reduce using rule 63 (var -> matel .)
    IF              reduce using rule 63 (var -> matel .)
    ID              reduce using rule 63 (var -> matel .)


state 22

    (5) instructions -> instructions instruction .
    {               reduce using rule 5 (instructions -> instructions instruction .)
    BREAK           reduce using rule 5 (instructions -> instructions instruction .)
    CONTINUE        reduce using rule 5 (instructions -> instructions instruction .)
    PRINT           reduce using rule 5 (instructions -> instructions instruction .)
    WHILE           reduce using rule 5 (instructions -> instructions instruction .)
    FOR             reduce using rule 5 (instructions -> instructions instruction .)
    RETURN          reduce using rule 5 (instructions -> instructions instruction .)
    IF              reduce using rule 5 (instructions -> instructions instruction .)
    ID              reduce using rule 5 (instructions -> instructions instruction .)
    $end            reduce using rule 5 (instructions -> instructions instruction .)
    }               reduce using rule 5 (instructions -> instructions instruction .)


state 23

    (6) instruction -> { instructions . }
    (5) instructions -> instructions . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    }               shift and go to state 57
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 22
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 24

    (7) instruction -> BREAK ; .
    {               reduce using rule 7 (instruction -> BREAK ; .)
    BREAK           reduce using rule 7 (instruction -> BREAK ; .)
    CONTINUE        reduce using rule 7 (instruction -> BREAK ; .)
    PRINT           reduce using rule 7 (instruction -> BREAK ; .)
    WHILE           reduce using rule 7 (instruction -> BREAK ; .)
    FOR             reduce using rule 7 (instruction -> BREAK ; .)
    RETURN          reduce using rule 7 (instruction -> BREAK ; .)
    IF              reduce using rule 7 (instruction -> BREAK ; .)
    ID              reduce using rule 7 (instruction -> BREAK ; .)
    $end            reduce using rule 7 (instruction -> BREAK ; .)
    }               reduce using rule 7 (instruction -> BREAK ; .)
    ELSE            reduce using rule 7 (instruction -> BREAK ; .)


state 25

    (8) instruction -> CONTINUE ; .
    {               reduce using rule 8 (instruction -> CONTINUE ; .)
    BREAK           reduce using rule 8 (instruction -> CONTINUE ; .)
    CONTINUE        reduce using rule 8 (instruction -> CONTINUE ; .)
    PRINT           reduce using rule 8 (instruction -> CONTINUE ; .)
    WHILE           reduce using rule 8 (instruction -> CONTINUE ; .)
    FOR             reduce using rule 8 (instruction -> CONTINUE ; .)
    RETURN          reduce using rule 8 (instruction -> CONTINUE ; .)
    IF              reduce using rule 8 (instruction -> CONTINUE ; .)
    ID              reduce using rule 8 (instruction -> CONTINUE ; .)
    $end            reduce using rule 8 (instruction -> CONTINUE ; .)
    }               reduce using rule 8 (instruction -> CONTINUE ; .)
    ELSE            reduce using rule 8 (instruction -> CONTINUE ; .)


state 26

    (9) instruction -> print_i ; .
    {               reduce using rule 9 (instruction -> print_i ; .)
    BREAK           reduce using rule 9 (instruction -> print_i ; .)
    CONTINUE        reduce using rule 9 (instruction -> print_i ; .)
    PRINT           reduce using rule 9 (instruction -> print_i ; .)
    WHILE           reduce using rule 9 (instruction -> print_i ; .)
    FOR             reduce using rule 9 (instruction -> print_i ; .)
    RETURN          reduce using rule 9 (instruction -> print_i ; .)
    IF              reduce using rule 9 (instruction -> print_i ; .)
    ID              reduce using rule 9 (instruction -> print_i ; .)
    $end            reduce using rule 9 (instruction -> print_i ; .)
    }               reduce using rule 9 (instruction -> print_i ; .)
    ELSE            reduce using rule 9 (instruction -> print_i ; .)


state 27

    (10) instruction -> assign ; .
    {               reduce using rule 10 (instruction -> assign ; .)
    BREAK           reduce using rule 10 (instruction -> assign ; .)
    CONTINUE        reduce using rule 10 (instruction -> assign ; .)
    PRINT           reduce using rule 10 (instruction -> assign ; .)
    WHILE           reduce using rule 10 (instruction -> assign ; .)
    FOR             reduce using rule 10 (instruction -> assign ; .)
    RETURN          reduce using rule 10 (instruction -> assign ; .)
    IF              reduce using rule 10 (instruction -> assign ; .)
    ID              reduce using rule 10 (instruction -> assign ; .)
    $end            reduce using rule 10 (instruction -> assign ; .)
    }               reduce using rule 10 (instruction -> assign ; .)
    ELSE            reduce using rule 10 (instruction -> assign ; .)


state 28

    (13) instruction -> return_i ; .
    {               reduce using rule 13 (instruction -> return_i ; .)
    BREAK           reduce using rule 13 (instruction -> return_i ; .)
    CONTINUE        reduce using rule 13 (instruction -> return_i ; .)
    PRINT           reduce using rule 13 (instruction -> return_i ; .)
    WHILE           reduce using rule 13 (instruction -> return_i ; .)
    FOR             reduce using rule 13 (instruction -> return_i ; .)
    RETURN          reduce using rule 13 (instruction -> return_i ; .)
    IF              reduce using rule 13 (instruction -> return_i ; .)
    ID              reduce using rule 13 (instruction -> return_i ; .)
    $end            reduce using rule 13 (instruction -> return_i ; .)
    }               reduce using rule 13 (instruction -> return_i ; .)
    ELSE            reduce using rule 13 (instruction -> return_i ; .)


state 29

    (32) print_i -> PRINT error .
    ;               reduce using rule 32 (print_i -> PRINT error .)


state 30

    (33) print_i -> PRINT printargs .
    ;               reduce using rule 33 (print_i -> PRINT printargs .)


state 31

    (34) printargs -> expr .
    (35) printargs -> expr . , printargs
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ;               reduce using rule 34 (printargs -> expr .)
    ,               shift and go to state 58
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 32

    (36) expr -> mat_fun . ( error )
    (37) expr -> mat_fun . ( mat_fun_args )
    (               shift and go to state 77


state 33

    (57) expr -> ( . expr )
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 78
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 34

    (38) expr -> vector .
    ,               reduce using rule 38 (expr -> vector .)
    DOTSUB          reduce using rule 38 (expr -> vector .)
    DOTADD          reduce using rule 38 (expr -> vector .)
    DOTDIV          reduce using rule 38 (expr -> vector .)
    DOTMUL          reduce using rule 38 (expr -> vector .)
    OR              reduce using rule 38 (expr -> vector .)
    AND             reduce using rule 38 (expr -> vector .)
    XOR             reduce using rule 38 (expr -> vector .)
    GREATEREQUAL    reduce using rule 38 (expr -> vector .)
    LESSEREQUAL     reduce using rule 38 (expr -> vector .)
    GREATER         reduce using rule 38 (expr -> vector .)
    LESSER          reduce using rule 38 (expr -> vector .)
    NOTEQUAL        reduce using rule 38 (expr -> vector .)
    EQUAL           reduce using rule 38 (expr -> vector .)
    /               reduce using rule 38 (expr -> vector .)
    *               reduce using rule 38 (expr -> vector .)
    -               reduce using rule 38 (expr -> vector .)
    +               reduce using rule 38 (expr -> vector .)
    '               reduce using rule 38 (expr -> vector .)
    ;               reduce using rule 38 (expr -> vector .)
    )               reduce using rule 38 (expr -> vector .)
    ]               reduce using rule 38 (expr -> vector .)
    :               reduce using rule 38 (expr -> vector .)
    error           reduce using rule 38 (expr -> vector .)
    {               reduce using rule 38 (expr -> vector .)
    BREAK           reduce using rule 38 (expr -> vector .)
    CONTINUE        reduce using rule 38 (expr -> vector .)
    PRINT           reduce using rule 38 (expr -> vector .)
    WHILE           reduce using rule 38 (expr -> vector .)
    FOR             reduce using rule 38 (expr -> vector .)
    RETURN          reduce using rule 38 (expr -> vector .)
    IF              reduce using rule 38 (expr -> vector .)
    ID              reduce using rule 38 (expr -> vector .)


state 35

    (77) unary -> - . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 79
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 36

    (56) expr -> unary .
    ,               reduce using rule 56 (expr -> unary .)
    DOTSUB          reduce using rule 56 (expr -> unary .)
    DOTADD          reduce using rule 56 (expr -> unary .)
    DOTDIV          reduce using rule 56 (expr -> unary .)
    DOTMUL          reduce using rule 56 (expr -> unary .)
    OR              reduce using rule 56 (expr -> unary .)
    AND             reduce using rule 56 (expr -> unary .)
    XOR             reduce using rule 56 (expr -> unary .)
    GREATEREQUAL    reduce using rule 56 (expr -> unary .)
    LESSEREQUAL     reduce using rule 56 (expr -> unary .)
    GREATER         reduce using rule 56 (expr -> unary .)
    LESSER          reduce using rule 56 (expr -> unary .)
    NOTEQUAL        reduce using rule 56 (expr -> unary .)
    EQUAL           reduce using rule 56 (expr -> unary .)
    /               reduce using rule 56 (expr -> unary .)
    *               reduce using rule 56 (expr -> unary .)
    -               reduce using rule 56 (expr -> unary .)
    +               reduce using rule 56 (expr -> unary .)
    '               reduce using rule 56 (expr -> unary .)
    ;               reduce using rule 56 (expr -> unary .)
    )               reduce using rule 56 (expr -> unary .)
    ]               reduce using rule 56 (expr -> unary .)
    :               reduce using rule 56 (expr -> unary .)
    error           reduce using rule 56 (expr -> unary .)
    {               reduce using rule 56 (expr -> unary .)
    BREAK           reduce using rule 56 (expr -> unary .)
    CONTINUE        reduce using rule 56 (expr -> unary .)
    PRINT           reduce using rule 56 (expr -> unary .)
    WHILE           reduce using rule 56 (expr -> unary .)
    FOR             reduce using rule 56 (expr -> unary .)
    RETURN          reduce using rule 56 (expr -> unary .)
    IF              reduce using rule 56 (expr -> unary .)
    ID              reduce using rule 56 (expr -> unary .)


state 37

    (58) expr -> var .
    ,               reduce using rule 58 (expr -> var .)
    DOTSUB          reduce using rule 58 (expr -> var .)
    DOTADD          reduce using rule 58 (expr -> var .)
    DOTDIV          reduce using rule 58 (expr -> var .)
    DOTMUL          reduce using rule 58 (expr -> var .)
    OR              reduce using rule 58 (expr -> var .)
    AND             reduce using rule 58 (expr -> var .)
    XOR             reduce using rule 58 (expr -> var .)
    GREATEREQUAL    reduce using rule 58 (expr -> var .)
    LESSEREQUAL     reduce using rule 58 (expr -> var .)
    GREATER         reduce using rule 58 (expr -> var .)
    LESSER          reduce using rule 58 (expr -> var .)
    NOTEQUAL        reduce using rule 58 (expr -> var .)
    EQUAL           reduce using rule 58 (expr -> var .)
    /               reduce using rule 58 (expr -> var .)
    *               reduce using rule 58 (expr -> var .)
    -               reduce using rule 58 (expr -> var .)
    +               reduce using rule 58 (expr -> var .)
    '               reduce using rule 58 (expr -> var .)
    ;               reduce using rule 58 (expr -> var .)
    )               reduce using rule 58 (expr -> var .)
    ]               reduce using rule 58 (expr -> var .)
    :               reduce using rule 58 (expr -> var .)
    error           reduce using rule 58 (expr -> var .)
    {               reduce using rule 58 (expr -> var .)
    BREAK           reduce using rule 58 (expr -> var .)
    CONTINUE        reduce using rule 58 (expr -> var .)
    PRINT           reduce using rule 58 (expr -> var .)
    WHILE           reduce using rule 58 (expr -> var .)
    FOR             reduce using rule 58 (expr -> var .)
    RETURN          reduce using rule 58 (expr -> var .)
    IF              reduce using rule 58 (expr -> var .)
    ID              reduce using rule 58 (expr -> var .)


state 38

    (59) expr -> FLOATNUM .
    ,               reduce using rule 59 (expr -> FLOATNUM .)
    DOTSUB          reduce using rule 59 (expr -> FLOATNUM .)
    DOTADD          reduce using rule 59 (expr -> FLOATNUM .)
    DOTDIV          reduce using rule 59 (expr -> FLOATNUM .)
    DOTMUL          reduce using rule 59 (expr -> FLOATNUM .)
    OR              reduce using rule 59 (expr -> FLOATNUM .)
    AND             reduce using rule 59 (expr -> FLOATNUM .)
    XOR             reduce using rule 59 (expr -> FLOATNUM .)
    GREATEREQUAL    reduce using rule 59 (expr -> FLOATNUM .)
    LESSEREQUAL     reduce using rule 59 (expr -> FLOATNUM .)
    GREATER         reduce using rule 59 (expr -> FLOATNUM .)
    LESSER          reduce using rule 59 (expr -> FLOATNUM .)
    NOTEQUAL        reduce using rule 59 (expr -> FLOATNUM .)
    EQUAL           reduce using rule 59 (expr -> FLOATNUM .)
    /               reduce using rule 59 (expr -> FLOATNUM .)
    *               reduce using rule 59 (expr -> FLOATNUM .)
    -               reduce using rule 59 (expr -> FLOATNUM .)
    +               reduce using rule 59 (expr -> FLOATNUM .)
    '               reduce using rule 59 (expr -> FLOATNUM .)
    ;               reduce using rule 59 (expr -> FLOATNUM .)
    )               reduce using rule 59 (expr -> FLOATNUM .)
    ]               reduce using rule 59 (expr -> FLOATNUM .)
    :               reduce using rule 59 (expr -> FLOATNUM .)
    error           reduce using rule 59 (expr -> FLOATNUM .)
    {               reduce using rule 59 (expr -> FLOATNUM .)
    BREAK           reduce using rule 59 (expr -> FLOATNUM .)
    CONTINUE        reduce using rule 59 (expr -> FLOATNUM .)
    PRINT           reduce using rule 59 (expr -> FLOATNUM .)
    WHILE           reduce using rule 59 (expr -> FLOATNUM .)
    FOR             reduce using rule 59 (expr -> FLOATNUM .)
    RETURN          reduce using rule 59 (expr -> FLOATNUM .)
    IF              reduce using rule 59 (expr -> FLOATNUM .)
    ID              reduce using rule 59 (expr -> FLOATNUM .)


state 39

    (60) expr -> INTNUM .
    ,               reduce using rule 60 (expr -> INTNUM .)
    DOTSUB          reduce using rule 60 (expr -> INTNUM .)
    DOTADD          reduce using rule 60 (expr -> INTNUM .)
    DOTDIV          reduce using rule 60 (expr -> INTNUM .)
    DOTMUL          reduce using rule 60 (expr -> INTNUM .)
    OR              reduce using rule 60 (expr -> INTNUM .)
    AND             reduce using rule 60 (expr -> INTNUM .)
    XOR             reduce using rule 60 (expr -> INTNUM .)
    GREATEREQUAL    reduce using rule 60 (expr -> INTNUM .)
    LESSEREQUAL     reduce using rule 60 (expr -> INTNUM .)
    GREATER         reduce using rule 60 (expr -> INTNUM .)
    LESSER          reduce using rule 60 (expr -> INTNUM .)
    NOTEQUAL        reduce using rule 60 (expr -> INTNUM .)
    EQUAL           reduce using rule 60 (expr -> INTNUM .)
    /               reduce using rule 60 (expr -> INTNUM .)
    *               reduce using rule 60 (expr -> INTNUM .)
    -               reduce using rule 60 (expr -> INTNUM .)
    +               reduce using rule 60 (expr -> INTNUM .)
    '               reduce using rule 60 (expr -> INTNUM .)
    ;               reduce using rule 60 (expr -> INTNUM .)
    )               reduce using rule 60 (expr -> INTNUM .)
    ]               reduce using rule 60 (expr -> INTNUM .)
    :               reduce using rule 60 (expr -> INTNUM .)
    error           reduce using rule 60 (expr -> INTNUM .)
    {               reduce using rule 60 (expr -> INTNUM .)
    BREAK           reduce using rule 60 (expr -> INTNUM .)
    CONTINUE        reduce using rule 60 (expr -> INTNUM .)
    PRINT           reduce using rule 60 (expr -> INTNUM .)
    WHILE           reduce using rule 60 (expr -> INTNUM .)
    FOR             reduce using rule 60 (expr -> INTNUM .)
    RETURN          reduce using rule 60 (expr -> INTNUM .)
    IF              reduce using rule 60 (expr -> INTNUM .)
    ID              reduce using rule 60 (expr -> INTNUM .)


state 40

    (61) expr -> STRING .
    ,               reduce using rule 61 (expr -> STRING .)
    DOTSUB          reduce using rule 61 (expr -> STRING .)
    DOTADD          reduce using rule 61 (expr -> STRING .)
    DOTDIV          reduce using rule 61 (expr -> STRING .)
    DOTMUL          reduce using rule 61 (expr -> STRING .)
    OR              reduce using rule 61 (expr -> STRING .)
    AND             reduce using rule 61 (expr -> STRING .)
    XOR             reduce using rule 61 (expr -> STRING .)
    GREATEREQUAL    reduce using rule 61 (expr -> STRING .)
    LESSEREQUAL     reduce using rule 61 (expr -> STRING .)
    GREATER         reduce using rule 61 (expr -> STRING .)
    LESSER          reduce using rule 61 (expr -> STRING .)
    NOTEQUAL        reduce using rule 61 (expr -> STRING .)
    EQUAL           reduce using rule 61 (expr -> STRING .)
    /               reduce using rule 61 (expr -> STRING .)
    *               reduce using rule 61 (expr -> STRING .)
    -               reduce using rule 61 (expr -> STRING .)
    +               reduce using rule 61 (expr -> STRING .)
    '               reduce using rule 61 (expr -> STRING .)
    ;               reduce using rule 61 (expr -> STRING .)
    )               reduce using rule 61 (expr -> STRING .)
    ]               reduce using rule 61 (expr -> STRING .)
    :               reduce using rule 61 (expr -> STRING .)
    error           reduce using rule 61 (expr -> STRING .)
    {               reduce using rule 61 (expr -> STRING .)
    BREAK           reduce using rule 61 (expr -> STRING .)
    CONTINUE        reduce using rule 61 (expr -> STRING .)
    PRINT           reduce using rule 61 (expr -> STRING .)
    WHILE           reduce using rule 61 (expr -> STRING .)
    FOR             reduce using rule 61 (expr -> STRING .)
    RETURN          reduce using rule 61 (expr -> STRING .)
    IF              reduce using rule 61 (expr -> STRING .)
    ID              reduce using rule 61 (expr -> STRING .)


state 41

    (83) mat_fun -> ONES .
    (               reduce using rule 83 (mat_fun -> ONES .)


state 42

    (84) mat_fun -> EYE .
    (               reduce using rule 84 (mat_fun -> EYE .)


state 43

    (85) mat_fun -> ZEROS .
    (               reduce using rule 85 (mat_fun -> ZEROS .)


state 44

    (78) vector -> [ . variables ]
    (79) variables -> . expr
    (80) variables -> . variables , expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    variables                      shift and go to state 80
    expr                           shift and go to state 81
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 45

    (76) unary -> NOT . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 82
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 46

    (65) assign -> var DIVASSIGN . error
    (70) assign -> var DIVASSIGN . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 83
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    var                            shift and go to state 37
    expr                           shift and go to state 84
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    matel                          shift and go to state 21

state 47

    (66) assign -> var MULASSIGN . error
    (71) assign -> var MULASSIGN . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 85
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    var                            shift and go to state 37
    expr                           shift and go to state 86
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    matel                          shift and go to state 21

state 48

    (67) assign -> var SUBASSIGN . error
    (72) assign -> var SUBASSIGN . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 87
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    var                            shift and go to state 37
    expr                           shift and go to state 88
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    matel                          shift and go to state 21

state 49

    (68) assign -> var ADDASSIGN . error
    (73) assign -> var ADDASSIGN . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 89
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    var                            shift and go to state 37
    expr                           shift and go to state 90
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    matel                          shift and go to state 21

state 50

    (69) assign -> var = . error
    (74) assign -> var = . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 91
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    var                            shift and go to state 37
    expr                           shift and go to state 92
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    matel                          shift and go to state 21

state 51

    (22) while_l -> WHILE ( . expr ) error
    (23) while_l -> WHILE ( . error ) instruction
    (24) while_l -> WHILE ( . expr ) instruction
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 94
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 93
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 52

    (25) for_l -> FOR ID . = expr : expr error
    (26) for_l -> FOR ID . = expr : error instruction
    (27) for_l -> FOR ID . = error : expr instruction
    (28) for_l -> FOR ID . = expr : expr instruction
    =               shift and go to state 95


state 53

    (64) matel -> ID [ . mat_fun_args ]
    (81) mat_fun_args -> . expr
    (82) mat_fun_args -> . mat_fun_args , expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    mat_fun_args                   shift and go to state 96
    expr                           shift and go to state 97
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 54

    (29) return_i -> RETURN error .
    ;               reduce using rule 29 (return_i -> RETURN error .)


state 55

    (30) return_i -> RETURN expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ;               reduce using rule 30 (return_i -> RETURN expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 56

    (15) if_i -> IF ( . expr ) instruction ELSE error
    (16) if_i -> IF ( . expr ) error ELSE instruction
    (17) if_i -> IF ( . expr ) error
    (18) if_i -> IF ( . error ) instruction ELSE instruction
    (19) if_i -> IF ( . error ) instruction
    (20) if_i -> IF ( . expr ) instruction ELSE instruction
    (21) if_i -> IF ( . expr ) instruction
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 99
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 98
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 57

    (6) instruction -> { instructions } .
    {               reduce using rule 6 (instruction -> { instructions } .)
    BREAK           reduce using rule 6 (instruction -> { instructions } .)
    CONTINUE        reduce using rule 6 (instruction -> { instructions } .)
    PRINT           reduce using rule 6 (instruction -> { instructions } .)
    WHILE           reduce using rule 6 (instruction -> { instructions } .)
    FOR             reduce using rule 6 (instruction -> { instructions } .)
    RETURN          reduce using rule 6 (instruction -> { instructions } .)
    IF              reduce using rule 6 (instruction -> { instructions } .)
    ID              reduce using rule 6 (instruction -> { instructions } .)
    $end            reduce using rule 6 (instruction -> { instructions } .)
    }               reduce using rule 6 (instruction -> { instructions } .)
    ELSE            reduce using rule 6 (instruction -> { instructions } .)


state 58

    (35) printargs -> expr , . printargs
    (34) printargs -> . expr
    (35) printargs -> . expr , printargs
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 31
    printargs                      shift and go to state 100
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 59

    (39) expr -> expr DOTSUB . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 101
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 60

    (40) expr -> expr DOTADD . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 102
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 61

    (41) expr -> expr DOTDIV . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 103
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 62

    (42) expr -> expr DOTMUL . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 104
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 63

    (43) expr -> expr OR . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 105
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 64

    (44) expr -> expr AND . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 106
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 65

    (45) expr -> expr XOR . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 107
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 66

    (46) expr -> expr GREATEREQUAL . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 108
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 67

    (47) expr -> expr LESSEREQUAL . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 109
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 68

    (48) expr -> expr GREATER . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 110
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 69

    (49) expr -> expr LESSER . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 111
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 70

    (50) expr -> expr NOTEQUAL . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 112
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 71

    (51) expr -> expr EQUAL . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 113
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 72

    (52) expr -> expr / . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 114
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 73

    (53) expr -> expr * . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 115
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 74

    (54) expr -> expr - . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 116
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 75

    (55) expr -> expr + . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 117
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 76

    (75) unary -> expr ' .
    ,               reduce using rule 75 (unary -> expr ' .)
    DOTSUB          reduce using rule 75 (unary -> expr ' .)
    DOTADD          reduce using rule 75 (unary -> expr ' .)
    DOTDIV          reduce using rule 75 (unary -> expr ' .)
    DOTMUL          reduce using rule 75 (unary -> expr ' .)
    OR              reduce using rule 75 (unary -> expr ' .)
    AND             reduce using rule 75 (unary -> expr ' .)
    XOR             reduce using rule 75 (unary -> expr ' .)
    GREATEREQUAL    reduce using rule 75 (unary -> expr ' .)
    LESSEREQUAL     reduce using rule 75 (unary -> expr ' .)
    GREATER         reduce using rule 75 (unary -> expr ' .)
    LESSER          reduce using rule 75 (unary -> expr ' .)
    NOTEQUAL        reduce using rule 75 (unary -> expr ' .)
    EQUAL           reduce using rule 75 (unary -> expr ' .)
    /               reduce using rule 75 (unary -> expr ' .)
    *               reduce using rule 75 (unary -> expr ' .)
    -               reduce using rule 75 (unary -> expr ' .)
    +               reduce using rule 75 (unary -> expr ' .)
    '               reduce using rule 75 (unary -> expr ' .)
    ;               reduce using rule 75 (unary -> expr ' .)
    )               reduce using rule 75 (unary -> expr ' .)
    ]               reduce using rule 75 (unary -> expr ' .)
    :               reduce using rule 75 (unary -> expr ' .)
    error           reduce using rule 75 (unary -> expr ' .)
    {               reduce using rule 75 (unary -> expr ' .)
    BREAK           reduce using rule 75 (unary -> expr ' .)
    CONTINUE        reduce using rule 75 (unary -> expr ' .)
    PRINT           reduce using rule 75 (unary -> expr ' .)
    WHILE           reduce using rule 75 (unary -> expr ' .)
    FOR             reduce using rule 75 (unary -> expr ' .)
    RETURN          reduce using rule 75 (unary -> expr ' .)
    IF              reduce using rule 75 (unary -> expr ' .)
    ID              reduce using rule 75 (unary -> expr ' .)


state 77

    (36) expr -> mat_fun ( . error )
    (37) expr -> mat_fun ( . mat_fun_args )
    (81) mat_fun_args -> . expr
    (82) mat_fun_args -> . mat_fun_args , expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 118
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    mat_fun                        shift and go to state 32
    mat_fun_args                   shift and go to state 119
    expr                           shift and go to state 97
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 78

    (57) expr -> ( expr . )
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    )               shift and go to state 120
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 79

    (77) unary -> - expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 77 (unary -> - expr .)
    DOTSUB          reduce using rule 77 (unary -> - expr .)
    DOTADD          reduce using rule 77 (unary -> - expr .)
    DOTDIV          reduce using rule 77 (unary -> - expr .)
    DOTMUL          reduce using rule 77 (unary -> - expr .)
    OR              reduce using rule 77 (unary -> - expr .)
    AND             reduce using rule 77 (unary -> - expr .)
    XOR             reduce using rule 77 (unary -> - expr .)
    GREATEREQUAL    reduce using rule 77 (unary -> - expr .)
    LESSEREQUAL     reduce using rule 77 (unary -> - expr .)
    GREATER         reduce using rule 77 (unary -> - expr .)
    LESSER          reduce using rule 77 (unary -> - expr .)
    NOTEQUAL        reduce using rule 77 (unary -> - expr .)
    EQUAL           reduce using rule 77 (unary -> - expr .)
    /               reduce using rule 77 (unary -> - expr .)
    *               reduce using rule 77 (unary -> - expr .)
    -               reduce using rule 77 (unary -> - expr .)
    +               reduce using rule 77 (unary -> - expr .)
    '               reduce using rule 77 (unary -> - expr .)
    ;               reduce using rule 77 (unary -> - expr .)
    )               reduce using rule 77 (unary -> - expr .)
    ]               reduce using rule 77 (unary -> - expr .)
    :               reduce using rule 77 (unary -> - expr .)
    error           reduce using rule 77 (unary -> - expr .)
    {               reduce using rule 77 (unary -> - expr .)
    BREAK           reduce using rule 77 (unary -> - expr .)
    CONTINUE        reduce using rule 77 (unary -> - expr .)
    PRINT           reduce using rule 77 (unary -> - expr .)
    WHILE           reduce using rule 77 (unary -> - expr .)
    FOR             reduce using rule 77 (unary -> - expr .)
    RETURN          reduce using rule 77 (unary -> - expr .)
    IF              reduce using rule 77 (unary -> - expr .)
    ID              reduce using rule 77 (unary -> - expr .)


state 80

    (78) vector -> [ variables . ]
    (80) variables -> variables . , expr
    ]               shift and go to state 121
    ,               shift and go to state 122


state 81

    (79) variables -> expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ]               reduce using rule 79 (variables -> expr .)
    ,               reduce using rule 79 (variables -> expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 82

    (76) unary -> NOT expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 76 (unary -> NOT expr .)
    DOTSUB          reduce using rule 76 (unary -> NOT expr .)
    DOTADD          reduce using rule 76 (unary -> NOT expr .)
    DOTDIV          reduce using rule 76 (unary -> NOT expr .)
    DOTMUL          reduce using rule 76 (unary -> NOT expr .)
    OR              reduce using rule 76 (unary -> NOT expr .)
    AND             reduce using rule 76 (unary -> NOT expr .)
    XOR             reduce using rule 76 (unary -> NOT expr .)
    GREATEREQUAL    reduce using rule 76 (unary -> NOT expr .)
    LESSEREQUAL     reduce using rule 76 (unary -> NOT expr .)
    GREATER         reduce using rule 76 (unary -> NOT expr .)
    LESSER          reduce using rule 76 (unary -> NOT expr .)
    NOTEQUAL        reduce using rule 76 (unary -> NOT expr .)
    EQUAL           reduce using rule 76 (unary -> NOT expr .)
    /               reduce using rule 76 (unary -> NOT expr .)
    *               reduce using rule 76 (unary -> NOT expr .)
    -               reduce using rule 76 (unary -> NOT expr .)
    +               reduce using rule 76 (unary -> NOT expr .)
    '               reduce using rule 76 (unary -> NOT expr .)
    ;               reduce using rule 76 (unary -> NOT expr .)
    )               reduce using rule 76 (unary -> NOT expr .)
    ]               reduce using rule 76 (unary -> NOT expr .)
    :               reduce using rule 76 (unary -> NOT expr .)
    error           reduce using rule 76 (unary -> NOT expr .)
    {               reduce using rule 76 (unary -> NOT expr .)
    BREAK           reduce using rule 76 (unary -> NOT expr .)
    CONTINUE        reduce using rule 76 (unary -> NOT expr .)
    PRINT           reduce using rule 76 (unary -> NOT expr .)
    WHILE           reduce using rule 76 (unary -> NOT expr .)
    FOR             reduce using rule 76 (unary -> NOT expr .)
    RETURN          reduce using rule 76 (unary -> NOT expr .)
    IF              reduce using rule 76 (unary -> NOT expr .)
    ID              reduce using rule 76 (unary -> NOT expr .)


state 83

    (65) assign -> var DIVASSIGN error .
    ;               reduce using rule 65 (assign -> var DIVASSIGN error .)


state 84

    (70) assign -> var DIVASSIGN expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ;               reduce using rule 70 (assign -> var DIVASSIGN expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 85

    (66) assign -> var MULASSIGN error .
    ;               reduce using rule 66 (assign -> var MULASSIGN error .)


state 86

    (71) assign -> var MULASSIGN expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ;               reduce using rule 71 (assign -> var MULASSIGN expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 87

    (67) assign -> var SUBASSIGN error .
    ;               reduce using rule 67 (assign -> var SUBASSIGN error .)


state 88

    (72) assign -> var SUBASSIGN expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ;               reduce using rule 72 (assign -> var SUBASSIGN expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 89

    (68) assign -> var ADDASSIGN error .
    ;               reduce using rule 68 (assign -> var ADDASSIGN error .)


state 90

    (73) assign -> var ADDASSIGN expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ;               reduce using rule 73 (assign -> var ADDASSIGN expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 91

    (69) assign -> var = error .
    ;               reduce using rule 69 (assign -> var = error .)


state 92

    (74) assign -> var = expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ;               reduce using rule 74 (assign -> var = expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 93

    (22) while_l -> WHILE ( expr . ) error
    (24) while_l -> WHILE ( expr . ) instruction
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    )               shift and go to state 123
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 94

    (23) while_l -> WHILE ( error . ) instruction
    )               shift and go to state 124


state 95

    (25) for_l -> FOR ID = . expr : expr error
    (26) for_l -> FOR ID = . expr : error instruction
    (27) for_l -> FOR ID = . error : expr instruction
    (28) for_l -> FOR ID = . expr : expr instruction
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 126
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 125
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 96

    (64) matel -> ID [ mat_fun_args . ]
    (82) mat_fun_args -> mat_fun_args . , expr
    ]               shift and go to state 127
    ,               shift and go to state 128


state 97

    (81) mat_fun_args -> expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ]               reduce using rule 81 (mat_fun_args -> expr .)
    ,               reduce using rule 81 (mat_fun_args -> expr .)
    )               reduce using rule 81 (mat_fun_args -> expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 98

    (15) if_i -> IF ( expr . ) instruction ELSE error
    (16) if_i -> IF ( expr . ) error ELSE instruction
    (17) if_i -> IF ( expr . ) error
    (20) if_i -> IF ( expr . ) instruction ELSE instruction
    (21) if_i -> IF ( expr . ) instruction
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    )               shift and go to state 129
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 99

    (18) if_i -> IF ( error . ) instruction ELSE instruction
    (19) if_i -> IF ( error . ) instruction
    )               shift and go to state 130


state 100

    (35) printargs -> expr , printargs .
    ;               reduce using rule 35 (printargs -> expr , printargs .)


state 101

    (39) expr -> expr DOTSUB expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 39 (expr -> expr DOTSUB expr .)
    DOTSUB          reduce using rule 39 (expr -> expr DOTSUB expr .)
    DOTADD          reduce using rule 39 (expr -> expr DOTSUB expr .)
    OR              reduce using rule 39 (expr -> expr DOTSUB expr .)
    AND             reduce using rule 39 (expr -> expr DOTSUB expr .)
    XOR             reduce using rule 39 (expr -> expr DOTSUB expr .)
    GREATEREQUAL    reduce using rule 39 (expr -> expr DOTSUB expr .)
    LESSEREQUAL     reduce using rule 39 (expr -> expr DOTSUB expr .)
    GREATER         reduce using rule 39 (expr -> expr DOTSUB expr .)
    LESSER          reduce using rule 39 (expr -> expr DOTSUB expr .)
    NOTEQUAL        reduce using rule 39 (expr -> expr DOTSUB expr .)
    EQUAL           reduce using rule 39 (expr -> expr DOTSUB expr .)
    -               reduce using rule 39 (expr -> expr DOTSUB expr .)
    +               reduce using rule 39 (expr -> expr DOTSUB expr .)
    '               reduce using rule 39 (expr -> expr DOTSUB expr .)
    ;               reduce using rule 39 (expr -> expr DOTSUB expr .)
    )               reduce using rule 39 (expr -> expr DOTSUB expr .)
    ]               reduce using rule 39 (expr -> expr DOTSUB expr .)
    :               reduce using rule 39 (expr -> expr DOTSUB expr .)
    error           reduce using rule 39 (expr -> expr DOTSUB expr .)
    {               reduce using rule 39 (expr -> expr DOTSUB expr .)
    BREAK           reduce using rule 39 (expr -> expr DOTSUB expr .)
    CONTINUE        reduce using rule 39 (expr -> expr DOTSUB expr .)
    PRINT           reduce using rule 39 (expr -> expr DOTSUB expr .)
    WHILE           reduce using rule 39 (expr -> expr DOTSUB expr .)
    FOR             reduce using rule 39 (expr -> expr DOTSUB expr .)
    RETURN          reduce using rule 39 (expr -> expr DOTSUB expr .)
    IF              reduce using rule 39 (expr -> expr DOTSUB expr .)
    ID              reduce using rule 39 (expr -> expr DOTSUB expr .)
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    /               shift and go to state 72
    *               shift and go to state 73


state 102

    (40) expr -> expr DOTADD expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 40 (expr -> expr DOTADD expr .)
    DOTSUB          reduce using rule 40 (expr -> expr DOTADD expr .)
    DOTADD          reduce using rule 40 (expr -> expr DOTADD expr .)
    OR              reduce using rule 40 (expr -> expr DOTADD expr .)
    AND             reduce using rule 40 (expr -> expr DOTADD expr .)
    XOR             reduce using rule 40 (expr -> expr DOTADD expr .)
    GREATEREQUAL    reduce using rule 40 (expr -> expr DOTADD expr .)
    LESSEREQUAL     reduce using rule 40 (expr -> expr DOTADD expr .)
    GREATER         reduce using rule 40 (expr -> expr DOTADD expr .)
    LESSER          reduce using rule 40 (expr -> expr DOTADD expr .)
    NOTEQUAL        reduce using rule 40 (expr -> expr DOTADD expr .)
    EQUAL           reduce using rule 40 (expr -> expr DOTADD expr .)
    -               reduce using rule 40 (expr -> expr DOTADD expr .)
    +               reduce using rule 40 (expr -> expr DOTADD expr .)
    '               reduce using rule 40 (expr -> expr DOTADD expr .)
    ;               reduce using rule 40 (expr -> expr DOTADD expr .)
    )               reduce using rule 40 (expr -> expr DOTADD expr .)
    ]               reduce using rule 40 (expr -> expr DOTADD expr .)
    :               reduce using rule 40 (expr -> expr DOTADD expr .)
    error           reduce using rule 40 (expr -> expr DOTADD expr .)
    {               reduce using rule 40 (expr -> expr DOTADD expr .)
    BREAK           reduce using rule 40 (expr -> expr DOTADD expr .)
    CONTINUE        reduce using rule 40 (expr -> expr DOTADD expr .)
    PRINT           reduce using rule 40 (expr -> expr DOTADD expr .)
    WHILE           reduce using rule 40 (expr -> expr DOTADD expr .)
    FOR             reduce using rule 40 (expr -> expr DOTADD expr .)
    RETURN          reduce using rule 40 (expr -> expr DOTADD expr .)
    IF              reduce using rule 40 (expr -> expr DOTADD expr .)
    ID              reduce using rule 40 (expr -> expr DOTADD expr .)
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    /               shift and go to state 72
    *               shift and go to state 73


state 103

    (41) expr -> expr DOTDIV expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 41 (expr -> expr DOTDIV expr .)
    DOTSUB          reduce using rule 41 (expr -> expr DOTDIV expr .)
    DOTADD          reduce using rule 41 (expr -> expr DOTDIV expr .)
    DOTDIV          reduce using rule 41 (expr -> expr DOTDIV expr .)
    DOTMUL          reduce using rule 41 (expr -> expr DOTDIV expr .)
    OR              reduce using rule 41 (expr -> expr DOTDIV expr .)
    AND             reduce using rule 41 (expr -> expr DOTDIV expr .)
    XOR             reduce using rule 41 (expr -> expr DOTDIV expr .)
    GREATEREQUAL    reduce using rule 41 (expr -> expr DOTDIV expr .)
    LESSEREQUAL     reduce using rule 41 (expr -> expr DOTDIV expr .)
    GREATER         reduce using rule 41 (expr -> expr DOTDIV expr .)
    LESSER          reduce using rule 41 (expr -> expr DOTDIV expr .)
    NOTEQUAL        reduce using rule 41 (expr -> expr DOTDIV expr .)
    EQUAL           reduce using rule 41 (expr -> expr DOTDIV expr .)
    /               reduce using rule 41 (expr -> expr DOTDIV expr .)
    *               reduce using rule 41 (expr -> expr DOTDIV expr .)
    -               reduce using rule 41 (expr -> expr DOTDIV expr .)
    +               reduce using rule 41 (expr -> expr DOTDIV expr .)
    '               reduce using rule 41 (expr -> expr DOTDIV expr .)
    ;               reduce using rule 41 (expr -> expr DOTDIV expr .)
    )               reduce using rule 41 (expr -> expr DOTDIV expr .)
    ]               reduce using rule 41 (expr -> expr DOTDIV expr .)
    :               reduce using rule 41 (expr -> expr DOTDIV expr .)
    error           reduce using rule 41 (expr -> expr DOTDIV expr .)
    {               reduce using rule 41 (expr -> expr DOTDIV expr .)
    BREAK           reduce using rule 41 (expr -> expr DOTDIV expr .)
    CONTINUE        reduce using rule 41 (expr -> expr DOTDIV expr .)
    PRINT           reduce using rule 41 (expr -> expr DOTDIV expr .)
    WHILE           reduce using rule 41 (expr -> expr DOTDIV expr .)
    FOR             reduce using rule 41 (expr -> expr DOTDIV expr .)
    RETURN          reduce using rule 41 (expr -> expr DOTDIV expr .)
    IF              reduce using rule 41 (expr -> expr DOTDIV expr .)
    ID              reduce using rule 41 (expr -> expr DOTDIV expr .)


state 104

    (42) expr -> expr DOTMUL expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 42 (expr -> expr DOTMUL expr .)
    DOTSUB          reduce using rule 42 (expr -> expr DOTMUL expr .)
    DOTADD          reduce using rule 42 (expr -> expr DOTMUL expr .)
    DOTDIV          reduce using rule 42 (expr -> expr DOTMUL expr .)
    DOTMUL          reduce using rule 42 (expr -> expr DOTMUL expr .)
    OR              reduce using rule 42 (expr -> expr DOTMUL expr .)
    AND             reduce using rule 42 (expr -> expr DOTMUL expr .)
    XOR             reduce using rule 42 (expr -> expr DOTMUL expr .)
    GREATEREQUAL    reduce using rule 42 (expr -> expr DOTMUL expr .)
    LESSEREQUAL     reduce using rule 42 (expr -> expr DOTMUL expr .)
    GREATER         reduce using rule 42 (expr -> expr DOTMUL expr .)
    LESSER          reduce using rule 42 (expr -> expr DOTMUL expr .)
    NOTEQUAL        reduce using rule 42 (expr -> expr DOTMUL expr .)
    EQUAL           reduce using rule 42 (expr -> expr DOTMUL expr .)
    /               reduce using rule 42 (expr -> expr DOTMUL expr .)
    *               reduce using rule 42 (expr -> expr DOTMUL expr .)
    -               reduce using rule 42 (expr -> expr DOTMUL expr .)
    +               reduce using rule 42 (expr -> expr DOTMUL expr .)
    '               reduce using rule 42 (expr -> expr DOTMUL expr .)
    ;               reduce using rule 42 (expr -> expr DOTMUL expr .)
    )               reduce using rule 42 (expr -> expr DOTMUL expr .)
    ]               reduce using rule 42 (expr -> expr DOTMUL expr .)
    :               reduce using rule 42 (expr -> expr DOTMUL expr .)
    error           reduce using rule 42 (expr -> expr DOTMUL expr .)
    {               reduce using rule 42 (expr -> expr DOTMUL expr .)
    BREAK           reduce using rule 42 (expr -> expr DOTMUL expr .)
    CONTINUE        reduce using rule 42 (expr -> expr DOTMUL expr .)
    PRINT           reduce using rule 42 (expr -> expr DOTMUL expr .)
    WHILE           reduce using rule 42 (expr -> expr DOTMUL expr .)
    FOR             reduce using rule 42 (expr -> expr DOTMUL expr .)
    RETURN          reduce using rule 42 (expr -> expr DOTMUL expr .)
    IF              reduce using rule 42 (expr -> expr DOTMUL expr .)
    ID              reduce using rule 42 (expr -> expr DOTMUL expr .)


state 105

    (43) expr -> expr OR expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 43 (expr -> expr OR expr .)
    OR              reduce using rule 43 (expr -> expr OR expr .)
    AND             reduce using rule 43 (expr -> expr OR expr .)
    XOR             reduce using rule 43 (expr -> expr OR expr .)
    GREATEREQUAL    reduce using rule 43 (expr -> expr OR expr .)
    LESSEREQUAL     reduce using rule 43 (expr -> expr OR expr .)
    GREATER         reduce using rule 43 (expr -> expr OR expr .)
    LESSER          reduce using rule 43 (expr -> expr OR expr .)
    NOTEQUAL        reduce using rule 43 (expr -> expr OR expr .)
    EQUAL           reduce using rule 43 (expr -> expr OR expr .)
    '               reduce using rule 43 (expr -> expr OR expr .)
    ;               reduce using rule 43 (expr -> expr OR expr .)
    )               reduce using rule 43 (expr -> expr OR expr .)
    ]               reduce using rule 43 (expr -> expr OR expr .)
    :               reduce using rule 43 (expr -> expr OR expr .)
    error           reduce using rule 43 (expr -> expr OR expr .)
    {               reduce using rule 43 (expr -> expr OR expr .)
    BREAK           reduce using rule 43 (expr -> expr OR expr .)
    CONTINUE        reduce using rule 43 (expr -> expr OR expr .)
    PRINT           reduce using rule 43 (expr -> expr OR expr .)
    WHILE           reduce using rule 43 (expr -> expr OR expr .)
    FOR             reduce using rule 43 (expr -> expr OR expr .)
    RETURN          reduce using rule 43 (expr -> expr OR expr .)
    IF              reduce using rule 43 (expr -> expr OR expr .)
    ID              reduce using rule 43 (expr -> expr OR expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75


state 106

    (44) expr -> expr AND expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 44 (expr -> expr AND expr .)
    OR              reduce using rule 44 (expr -> expr AND expr .)
    AND             reduce using rule 44 (expr -> expr AND expr .)
    XOR             reduce using rule 44 (expr -> expr AND expr .)
    GREATEREQUAL    reduce using rule 44 (expr -> expr AND expr .)
    LESSEREQUAL     reduce using rule 44 (expr -> expr AND expr .)
    GREATER         reduce using rule 44 (expr -> expr AND expr .)
    LESSER          reduce using rule 44 (expr -> expr AND expr .)
    NOTEQUAL        reduce using rule 44 (expr -> expr AND expr .)
    EQUAL           reduce using rule 44 (expr -> expr AND expr .)
    '               reduce using rule 44 (expr -> expr AND expr .)
    ;               reduce using rule 44 (expr -> expr AND expr .)
    )               reduce using rule 44 (expr -> expr AND expr .)
    ]               reduce using rule 44 (expr -> expr AND expr .)
    :               reduce using rule 44 (expr -> expr AND expr .)
    error           reduce using rule 44 (expr -> expr AND expr .)
    {               reduce using rule 44 (expr -> expr AND expr .)
    BREAK           reduce using rule 44 (expr -> expr AND expr .)
    CONTINUE        reduce using rule 44 (expr -> expr AND expr .)
    PRINT           reduce using rule 44 (expr -> expr AND expr .)
    WHILE           reduce using rule 44 (expr -> expr AND expr .)
    FOR             reduce using rule 44 (expr -> expr AND expr .)
    RETURN          reduce using rule 44 (expr -> expr AND expr .)
    IF              reduce using rule 44 (expr -> expr AND expr .)
    ID              reduce using rule 44 (expr -> expr AND expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75


state 107

    (45) expr -> expr XOR expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 45 (expr -> expr XOR expr .)
    OR              reduce using rule 45 (expr -> expr XOR expr .)
    AND             reduce using rule 45 (expr -> expr XOR expr .)
    XOR             reduce using rule 45 (expr -> expr XOR expr .)
    GREATEREQUAL    reduce using rule 45 (expr -> expr XOR expr .)
    LESSEREQUAL     reduce using rule 45 (expr -> expr XOR expr .)
    GREATER         reduce using rule 45 (expr -> expr XOR expr .)
    LESSER          reduce using rule 45 (expr -> expr XOR expr .)
    NOTEQUAL        reduce using rule 45 (expr -> expr XOR expr .)
    EQUAL           reduce using rule 45 (expr -> expr XOR expr .)
    '               reduce using rule 45 (expr -> expr XOR expr .)
    ;               reduce using rule 45 (expr -> expr XOR expr .)
    )               reduce using rule 45 (expr -> expr XOR expr .)
    ]               reduce using rule 45 (expr -> expr XOR expr .)
    :               reduce using rule 45 (expr -> expr XOR expr .)
    error           reduce using rule 45 (expr -> expr XOR expr .)
    {               reduce using rule 45 (expr -> expr XOR expr .)
    BREAK           reduce using rule 45 (expr -> expr XOR expr .)
    CONTINUE        reduce using rule 45 (expr -> expr XOR expr .)
    PRINT           reduce using rule 45 (expr -> expr XOR expr .)
    WHILE           reduce using rule 45 (expr -> expr XOR expr .)
    FOR             reduce using rule 45 (expr -> expr XOR expr .)
    RETURN          reduce using rule 45 (expr -> expr XOR expr .)
    IF              reduce using rule 45 (expr -> expr XOR expr .)
    ID              reduce using rule 45 (expr -> expr XOR expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75


state 108

    (46) expr -> expr GREATEREQUAL expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    GREATEREQUAL    reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    LESSEREQUAL     reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    GREATER         reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    LESSER          reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    NOTEQUAL        reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    EQUAL           reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    '               reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    ;               reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    )               reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    ]               reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    :               reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    error           reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    {               reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    BREAK           reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    CONTINUE        reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    PRINT           reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    WHILE           reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    FOR             reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    RETURN          reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    IF              reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    ID              reduce using rule 46 (expr -> expr GREATEREQUAL expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75


state 109

    (47) expr -> expr LESSEREQUAL expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    GREATEREQUAL    reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    LESSEREQUAL     reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    GREATER         reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    LESSER          reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    NOTEQUAL        reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    EQUAL           reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    '               reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    ;               reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    )               reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    ]               reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    :               reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    error           reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    {               reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    BREAK           reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    CONTINUE        reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    PRINT           reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    WHILE           reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    FOR             reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    RETURN          reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    IF              reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    ID              reduce using rule 47 (expr -> expr LESSEREQUAL expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75


state 110

    (48) expr -> expr GREATER expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 48 (expr -> expr GREATER expr .)
    GREATEREQUAL    reduce using rule 48 (expr -> expr GREATER expr .)
    LESSEREQUAL     reduce using rule 48 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 48 (expr -> expr GREATER expr .)
    LESSER          reduce using rule 48 (expr -> expr GREATER expr .)
    NOTEQUAL        reduce using rule 48 (expr -> expr GREATER expr .)
    EQUAL           reduce using rule 48 (expr -> expr GREATER expr .)
    '               reduce using rule 48 (expr -> expr GREATER expr .)
    ;               reduce using rule 48 (expr -> expr GREATER expr .)
    )               reduce using rule 48 (expr -> expr GREATER expr .)
    ]               reduce using rule 48 (expr -> expr GREATER expr .)
    :               reduce using rule 48 (expr -> expr GREATER expr .)
    error           reduce using rule 48 (expr -> expr GREATER expr .)
    {               reduce using rule 48 (expr -> expr GREATER expr .)
    BREAK           reduce using rule 48 (expr -> expr GREATER expr .)
    CONTINUE        reduce using rule 48 (expr -> expr GREATER expr .)
    PRINT           reduce using rule 48 (expr -> expr GREATER expr .)
    WHILE           reduce using rule 48 (expr -> expr GREATER expr .)
    FOR             reduce using rule 48 (expr -> expr GREATER expr .)
    RETURN          reduce using rule 48 (expr -> expr GREATER expr .)
    IF              reduce using rule 48 (expr -> expr GREATER expr .)
    ID              reduce using rule 48 (expr -> expr GREATER expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75


state 111

    (49) expr -> expr LESSER expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 49 (expr -> expr LESSER expr .)
    GREATEREQUAL    reduce using rule 49 (expr -> expr LESSER expr .)
    LESSEREQUAL     reduce using rule 49 (expr -> expr LESSER expr .)
    GREATER         reduce using rule 49 (expr -> expr LESSER expr .)
    LESSER          reduce using rule 49 (expr -> expr LESSER expr .)
    NOTEQUAL        reduce using rule 49 (expr -> expr LESSER expr .)
    EQUAL           reduce using rule 49 (expr -> expr LESSER expr .)
    '               reduce using rule 49 (expr -> expr LESSER expr .)
    ;               reduce using rule 49 (expr -> expr LESSER expr .)
    )               reduce using rule 49 (expr -> expr LESSER expr .)
    ]               reduce using rule 49 (expr -> expr LESSER expr .)
    :               reduce using rule 49 (expr -> expr LESSER expr .)
    error           reduce using rule 49 (expr -> expr LESSER expr .)
    {               reduce using rule 49 (expr -> expr LESSER expr .)
    BREAK           reduce using rule 49 (expr -> expr LESSER expr .)
    CONTINUE        reduce using rule 49 (expr -> expr LESSER expr .)
    PRINT           reduce using rule 49 (expr -> expr LESSER expr .)
    WHILE           reduce using rule 49 (expr -> expr LESSER expr .)
    FOR             reduce using rule 49 (expr -> expr LESSER expr .)
    RETURN          reduce using rule 49 (expr -> expr LESSER expr .)
    IF              reduce using rule 49 (expr -> expr LESSER expr .)
    ID              reduce using rule 49 (expr -> expr LESSER expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75


state 112

    (50) expr -> expr NOTEQUAL expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    GREATEREQUAL    reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    LESSEREQUAL     reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    GREATER         reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    LESSER          reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    NOTEQUAL        reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    EQUAL           reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    '               reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    ;               reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    )               reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    ]               reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    :               reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    error           reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    {               reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    BREAK           reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    CONTINUE        reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    PRINT           reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    WHILE           reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    FOR             reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    RETURN          reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    IF              reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    ID              reduce using rule 50 (expr -> expr NOTEQUAL expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75


state 113

    (51) expr -> expr EQUAL expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 51 (expr -> expr EQUAL expr .)
    GREATEREQUAL    reduce using rule 51 (expr -> expr EQUAL expr .)
    LESSEREQUAL     reduce using rule 51 (expr -> expr EQUAL expr .)
    GREATER         reduce using rule 51 (expr -> expr EQUAL expr .)
    LESSER          reduce using rule 51 (expr -> expr EQUAL expr .)
    NOTEQUAL        reduce using rule 51 (expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 51 (expr -> expr EQUAL expr .)
    '               reduce using rule 51 (expr -> expr EQUAL expr .)
    ;               reduce using rule 51 (expr -> expr EQUAL expr .)
    )               reduce using rule 51 (expr -> expr EQUAL expr .)
    ]               reduce using rule 51 (expr -> expr EQUAL expr .)
    :               reduce using rule 51 (expr -> expr EQUAL expr .)
    error           reduce using rule 51 (expr -> expr EQUAL expr .)
    {               reduce using rule 51 (expr -> expr EQUAL expr .)
    BREAK           reduce using rule 51 (expr -> expr EQUAL expr .)
    CONTINUE        reduce using rule 51 (expr -> expr EQUAL expr .)
    PRINT           reduce using rule 51 (expr -> expr EQUAL expr .)
    WHILE           reduce using rule 51 (expr -> expr EQUAL expr .)
    FOR             reduce using rule 51 (expr -> expr EQUAL expr .)
    RETURN          reduce using rule 51 (expr -> expr EQUAL expr .)
    IF              reduce using rule 51 (expr -> expr EQUAL expr .)
    ID              reduce using rule 51 (expr -> expr EQUAL expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75


state 114

    (52) expr -> expr / expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 52 (expr -> expr / expr .)
    DOTSUB          reduce using rule 52 (expr -> expr / expr .)
    DOTADD          reduce using rule 52 (expr -> expr / expr .)
    DOTDIV          reduce using rule 52 (expr -> expr / expr .)
    DOTMUL          reduce using rule 52 (expr -> expr / expr .)
    OR              reduce using rule 52 (expr -> expr / expr .)
    AND             reduce using rule 52 (expr -> expr / expr .)
    XOR             reduce using rule 52 (expr -> expr / expr .)
    GREATEREQUAL    reduce using rule 52 (expr -> expr / expr .)
    LESSEREQUAL     reduce using rule 52 (expr -> expr / expr .)
    GREATER         reduce using rule 52 (expr -> expr / expr .)
    LESSER          reduce using rule 52 (expr -> expr / expr .)
    NOTEQUAL        reduce using rule 52 (expr -> expr / expr .)
    EQUAL           reduce using rule 52 (expr -> expr / expr .)
    /               reduce using rule 52 (expr -> expr / expr .)
    *               reduce using rule 52 (expr -> expr / expr .)
    -               reduce using rule 52 (expr -> expr / expr .)
    +               reduce using rule 52 (expr -> expr / expr .)
    '               reduce using rule 52 (expr -> expr / expr .)
    ;               reduce using rule 52 (expr -> expr / expr .)
    )               reduce using rule 52 (expr -> expr / expr .)
    ]               reduce using rule 52 (expr -> expr / expr .)
    :               reduce using rule 52 (expr -> expr / expr .)
    error           reduce using rule 52 (expr -> expr / expr .)
    {               reduce using rule 52 (expr -> expr / expr .)
    BREAK           reduce using rule 52 (expr -> expr / expr .)
    CONTINUE        reduce using rule 52 (expr -> expr / expr .)
    PRINT           reduce using rule 52 (expr -> expr / expr .)
    WHILE           reduce using rule 52 (expr -> expr / expr .)
    FOR             reduce using rule 52 (expr -> expr / expr .)
    RETURN          reduce using rule 52 (expr -> expr / expr .)
    IF              reduce using rule 52 (expr -> expr / expr .)
    ID              reduce using rule 52 (expr -> expr / expr .)


state 115

    (53) expr -> expr * expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 53 (expr -> expr * expr .)
    DOTSUB          reduce using rule 53 (expr -> expr * expr .)
    DOTADD          reduce using rule 53 (expr -> expr * expr .)
    DOTDIV          reduce using rule 53 (expr -> expr * expr .)
    DOTMUL          reduce using rule 53 (expr -> expr * expr .)
    OR              reduce using rule 53 (expr -> expr * expr .)
    AND             reduce using rule 53 (expr -> expr * expr .)
    XOR             reduce using rule 53 (expr -> expr * expr .)
    GREATEREQUAL    reduce using rule 53 (expr -> expr * expr .)
    LESSEREQUAL     reduce using rule 53 (expr -> expr * expr .)
    GREATER         reduce using rule 53 (expr -> expr * expr .)
    LESSER          reduce using rule 53 (expr -> expr * expr .)
    NOTEQUAL        reduce using rule 53 (expr -> expr * expr .)
    EQUAL           reduce using rule 53 (expr -> expr * expr .)
    /               reduce using rule 53 (expr -> expr * expr .)
    *               reduce using rule 53 (expr -> expr * expr .)
    -               reduce using rule 53 (expr -> expr * expr .)
    +               reduce using rule 53 (expr -> expr * expr .)
    '               reduce using rule 53 (expr -> expr * expr .)
    ;               reduce using rule 53 (expr -> expr * expr .)
    )               reduce using rule 53 (expr -> expr * expr .)
    ]               reduce using rule 53 (expr -> expr * expr .)
    :               reduce using rule 53 (expr -> expr * expr .)
    error           reduce using rule 53 (expr -> expr * expr .)
    {               reduce using rule 53 (expr -> expr * expr .)
    BREAK           reduce using rule 53 (expr -> expr * expr .)
    CONTINUE        reduce using rule 53 (expr -> expr * expr .)
    PRINT           reduce using rule 53 (expr -> expr * expr .)
    WHILE           reduce using rule 53 (expr -> expr * expr .)
    FOR             reduce using rule 53 (expr -> expr * expr .)
    RETURN          reduce using rule 53 (expr -> expr * expr .)
    IF              reduce using rule 53 (expr -> expr * expr .)
    ID              reduce using rule 53 (expr -> expr * expr .)


state 116

    (54) expr -> expr - expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 54 (expr -> expr - expr .)
    DOTSUB          reduce using rule 54 (expr -> expr - expr .)
    DOTADD          reduce using rule 54 (expr -> expr - expr .)
    OR              reduce using rule 54 (expr -> expr - expr .)
    AND             reduce using rule 54 (expr -> expr - expr .)
    XOR             reduce using rule 54 (expr -> expr - expr .)
    GREATEREQUAL    reduce using rule 54 (expr -> expr - expr .)
    LESSEREQUAL     reduce using rule 54 (expr -> expr - expr .)
    GREATER         reduce using rule 54 (expr -> expr - expr .)
    LESSER          reduce using rule 54 (expr -> expr - expr .)
    NOTEQUAL        reduce using rule 54 (expr -> expr - expr .)
    EQUAL           reduce using rule 54 (expr -> expr - expr .)
    -               reduce using rule 54 (expr -> expr - expr .)
    +               reduce using rule 54 (expr -> expr - expr .)
    '               reduce using rule 54 (expr -> expr - expr .)
    ;               reduce using rule 54 (expr -> expr - expr .)
    )               reduce using rule 54 (expr -> expr - expr .)
    ]               reduce using rule 54 (expr -> expr - expr .)
    :               reduce using rule 54 (expr -> expr - expr .)
    error           reduce using rule 54 (expr -> expr - expr .)
    {               reduce using rule 54 (expr -> expr - expr .)
    BREAK           reduce using rule 54 (expr -> expr - expr .)
    CONTINUE        reduce using rule 54 (expr -> expr - expr .)
    PRINT           reduce using rule 54 (expr -> expr - expr .)
    WHILE           reduce using rule 54 (expr -> expr - expr .)
    FOR             reduce using rule 54 (expr -> expr - expr .)
    RETURN          reduce using rule 54 (expr -> expr - expr .)
    IF              reduce using rule 54 (expr -> expr - expr .)
    ID              reduce using rule 54 (expr -> expr - expr .)
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    /               shift and go to state 72
    *               shift and go to state 73


state 117

    (55) expr -> expr + expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ,               reduce using rule 55 (expr -> expr + expr .)
    DOTSUB          reduce using rule 55 (expr -> expr + expr .)
    DOTADD          reduce using rule 55 (expr -> expr + expr .)
    OR              reduce using rule 55 (expr -> expr + expr .)
    AND             reduce using rule 55 (expr -> expr + expr .)
    XOR             reduce using rule 55 (expr -> expr + expr .)
    GREATEREQUAL    reduce using rule 55 (expr -> expr + expr .)
    LESSEREQUAL     reduce using rule 55 (expr -> expr + expr .)
    GREATER         reduce using rule 55 (expr -> expr + expr .)
    LESSER          reduce using rule 55 (expr -> expr + expr .)
    NOTEQUAL        reduce using rule 55 (expr -> expr + expr .)
    EQUAL           reduce using rule 55 (expr -> expr + expr .)
    -               reduce using rule 55 (expr -> expr + expr .)
    +               reduce using rule 55 (expr -> expr + expr .)
    '               reduce using rule 55 (expr -> expr + expr .)
    ;               reduce using rule 55 (expr -> expr + expr .)
    )               reduce using rule 55 (expr -> expr + expr .)
    ]               reduce using rule 55 (expr -> expr + expr .)
    :               reduce using rule 55 (expr -> expr + expr .)
    error           reduce using rule 55 (expr -> expr + expr .)
    {               reduce using rule 55 (expr -> expr + expr .)
    BREAK           reduce using rule 55 (expr -> expr + expr .)
    CONTINUE        reduce using rule 55 (expr -> expr + expr .)
    PRINT           reduce using rule 55 (expr -> expr + expr .)
    WHILE           reduce using rule 55 (expr -> expr + expr .)
    FOR             reduce using rule 55 (expr -> expr + expr .)
    RETURN          reduce using rule 55 (expr -> expr + expr .)
    IF              reduce using rule 55 (expr -> expr + expr .)
    ID              reduce using rule 55 (expr -> expr + expr .)
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    /               shift and go to state 72
    *               shift and go to state 73


state 118

    (36) expr -> mat_fun ( error . )
    )               shift and go to state 131


state 119

    (37) expr -> mat_fun ( mat_fun_args . )
    (82) mat_fun_args -> mat_fun_args . , expr
    )               shift and go to state 132
    ,               shift and go to state 128


state 120

    (57) expr -> ( expr ) .
    ,               reduce using rule 57 (expr -> ( expr ) .)
    DOTSUB          reduce using rule 57 (expr -> ( expr ) .)
    DOTADD          reduce using rule 57 (expr -> ( expr ) .)
    DOTDIV          reduce using rule 57 (expr -> ( expr ) .)
    DOTMUL          reduce using rule 57 (expr -> ( expr ) .)
    OR              reduce using rule 57 (expr -> ( expr ) .)
    AND             reduce using rule 57 (expr -> ( expr ) .)
    XOR             reduce using rule 57 (expr -> ( expr ) .)
    GREATEREQUAL    reduce using rule 57 (expr -> ( expr ) .)
    LESSEREQUAL     reduce using rule 57 (expr -> ( expr ) .)
    GREATER         reduce using rule 57 (expr -> ( expr ) .)
    LESSER          reduce using rule 57 (expr -> ( expr ) .)
    NOTEQUAL        reduce using rule 57 (expr -> ( expr ) .)
    EQUAL           reduce using rule 57 (expr -> ( expr ) .)
    /               reduce using rule 57 (expr -> ( expr ) .)
    *               reduce using rule 57 (expr -> ( expr ) .)
    -               reduce using rule 57 (expr -> ( expr ) .)
    +               reduce using rule 57 (expr -> ( expr ) .)
    '               reduce using rule 57 (expr -> ( expr ) .)
    ;               reduce using rule 57 (expr -> ( expr ) .)
    )               reduce using rule 57 (expr -> ( expr ) .)
    ]               reduce using rule 57 (expr -> ( expr ) .)
    :               reduce using rule 57 (expr -> ( expr ) .)
    error           reduce using rule 57 (expr -> ( expr ) .)
    {               reduce using rule 57 (expr -> ( expr ) .)
    BREAK           reduce using rule 57 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 57 (expr -> ( expr ) .)
    PRINT           reduce using rule 57 (expr -> ( expr ) .)
    WHILE           reduce using rule 57 (expr -> ( expr ) .)
    FOR             reduce using rule 57 (expr -> ( expr ) .)
    RETURN          reduce using rule 57 (expr -> ( expr ) .)
    IF              reduce using rule 57 (expr -> ( expr ) .)
    ID              reduce using rule 57 (expr -> ( expr ) .)


state 121

    (78) vector -> [ variables ] .
    ,               reduce using rule 78 (vector -> [ variables ] .)
    DOTSUB          reduce using rule 78 (vector -> [ variables ] .)
    DOTADD          reduce using rule 78 (vector -> [ variables ] .)
    DOTDIV          reduce using rule 78 (vector -> [ variables ] .)
    DOTMUL          reduce using rule 78 (vector -> [ variables ] .)
    OR              reduce using rule 78 (vector -> [ variables ] .)
    AND             reduce using rule 78 (vector -> [ variables ] .)
    XOR             reduce using rule 78 (vector -> [ variables ] .)
    GREATEREQUAL    reduce using rule 78 (vector -> [ variables ] .)
    LESSEREQUAL     reduce using rule 78 (vector -> [ variables ] .)
    GREATER         reduce using rule 78 (vector -> [ variables ] .)
    LESSER          reduce using rule 78 (vector -> [ variables ] .)
    NOTEQUAL        reduce using rule 78 (vector -> [ variables ] .)
    EQUAL           reduce using rule 78 (vector -> [ variables ] .)
    /               reduce using rule 78 (vector -> [ variables ] .)
    *               reduce using rule 78 (vector -> [ variables ] .)
    -               reduce using rule 78 (vector -> [ variables ] .)
    +               reduce using rule 78 (vector -> [ variables ] .)
    '               reduce using rule 78 (vector -> [ variables ] .)
    ;               reduce using rule 78 (vector -> [ variables ] .)
    )               reduce using rule 78 (vector -> [ variables ] .)
    ]               reduce using rule 78 (vector -> [ variables ] .)
    :               reduce using rule 78 (vector -> [ variables ] .)
    error           reduce using rule 78 (vector -> [ variables ] .)
    {               reduce using rule 78 (vector -> [ variables ] .)
    BREAK           reduce using rule 78 (vector -> [ variables ] .)
    CONTINUE        reduce using rule 78 (vector -> [ variables ] .)
    PRINT           reduce using rule 78 (vector -> [ variables ] .)
    WHILE           reduce using rule 78 (vector -> [ variables ] .)
    FOR             reduce using rule 78 (vector -> [ variables ] .)
    RETURN          reduce using rule 78 (vector -> [ variables ] .)
    IF              reduce using rule 78 (vector -> [ variables ] .)
    ID              reduce using rule 78 (vector -> [ variables ] .)


state 122

    (80) variables -> variables , . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 133
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 123

    (22) while_l -> WHILE ( expr ) . error
    (24) while_l -> WHILE ( expr ) . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 134
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 135
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 124

    (23) while_l -> WHILE ( error ) . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 136
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 125

    (25) for_l -> FOR ID = expr . : expr error
    (26) for_l -> FOR ID = expr . : error instruction
    (28) for_l -> FOR ID = expr . : expr instruction
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    :               shift and go to state 137
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 126

    (27) for_l -> FOR ID = error . : expr instruction
    :               shift and go to state 138


state 127

    (64) matel -> ID [ mat_fun_args ] .
    DIVASSIGN       reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    MULASSIGN       reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    SUBASSIGN       reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    ADDASSIGN       reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    =               reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    ,               reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    DOTSUB          reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    DOTADD          reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    DOTDIV          reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    DOTMUL          reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    OR              reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    AND             reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    XOR             reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    GREATEREQUAL    reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    LESSEREQUAL     reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    GREATER         reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    LESSER          reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    NOTEQUAL        reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    EQUAL           reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    /               reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    *               reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    -               reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    +               reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    '               reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    ;               reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    )               reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    ]               reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    :               reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    error           reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    {               reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    BREAK           reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    CONTINUE        reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    PRINT           reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    WHILE           reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    FOR             reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    RETURN          reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    IF              reduce using rule 64 (matel -> ID [ mat_fun_args ] .)
    ID              reduce using rule 64 (matel -> ID [ mat_fun_args ] .)


state 128

    (82) mat_fun_args -> mat_fun_args , . expr
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 139
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 129

    (15) if_i -> IF ( expr ) . instruction ELSE error
    (16) if_i -> IF ( expr ) . error ELSE instruction
    (17) if_i -> IF ( expr ) . error
    (20) if_i -> IF ( expr ) . instruction ELSE instruction
    (21) if_i -> IF ( expr ) . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 141
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 140
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 130

    (18) if_i -> IF ( error ) . instruction ELSE instruction
    (19) if_i -> IF ( error ) . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 142
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 131

    (36) expr -> mat_fun ( error ) .
    ,               reduce using rule 36 (expr -> mat_fun ( error ) .)
    DOTSUB          reduce using rule 36 (expr -> mat_fun ( error ) .)
    DOTADD          reduce using rule 36 (expr -> mat_fun ( error ) .)
    DOTDIV          reduce using rule 36 (expr -> mat_fun ( error ) .)
    DOTMUL          reduce using rule 36 (expr -> mat_fun ( error ) .)
    OR              reduce using rule 36 (expr -> mat_fun ( error ) .)
    AND             reduce using rule 36 (expr -> mat_fun ( error ) .)
    XOR             reduce using rule 36 (expr -> mat_fun ( error ) .)
    GREATEREQUAL    reduce using rule 36 (expr -> mat_fun ( error ) .)
    LESSEREQUAL     reduce using rule 36 (expr -> mat_fun ( error ) .)
    GREATER         reduce using rule 36 (expr -> mat_fun ( error ) .)
    LESSER          reduce using rule 36 (expr -> mat_fun ( error ) .)
    NOTEQUAL        reduce using rule 36 (expr -> mat_fun ( error ) .)
    EQUAL           reduce using rule 36 (expr -> mat_fun ( error ) .)
    /               reduce using rule 36 (expr -> mat_fun ( error ) .)
    *               reduce using rule 36 (expr -> mat_fun ( error ) .)
    -               reduce using rule 36 (expr -> mat_fun ( error ) .)
    +               reduce using rule 36 (expr -> mat_fun ( error ) .)
    '               reduce using rule 36 (expr -> mat_fun ( error ) .)
    ;               reduce using rule 36 (expr -> mat_fun ( error ) .)
    )               reduce using rule 36 (expr -> mat_fun ( error ) .)
    ]               reduce using rule 36 (expr -> mat_fun ( error ) .)
    :               reduce using rule 36 (expr -> mat_fun ( error ) .)
    error           reduce using rule 36 (expr -> mat_fun ( error ) .)
    {               reduce using rule 36 (expr -> mat_fun ( error ) .)
    BREAK           reduce using rule 36 (expr -> mat_fun ( error ) .)
    CONTINUE        reduce using rule 36 (expr -> mat_fun ( error ) .)
    PRINT           reduce using rule 36 (expr -> mat_fun ( error ) .)
    WHILE           reduce using rule 36 (expr -> mat_fun ( error ) .)
    FOR             reduce using rule 36 (expr -> mat_fun ( error ) .)
    RETURN          reduce using rule 36 (expr -> mat_fun ( error ) .)
    IF              reduce using rule 36 (expr -> mat_fun ( error ) .)
    ID              reduce using rule 36 (expr -> mat_fun ( error ) .)


state 132

    (37) expr -> mat_fun ( mat_fun_args ) .
    ,               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    DOTSUB          reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    DOTADD          reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    DOTDIV          reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    DOTMUL          reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    OR              reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    AND             reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    XOR             reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    GREATEREQUAL    reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    LESSEREQUAL     reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    GREATER         reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    LESSER          reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    NOTEQUAL        reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    EQUAL           reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    /               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    *               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    -               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    +               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    '               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    ;               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    )               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    ]               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    :               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    error           reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    {               reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    BREAK           reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    CONTINUE        reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    PRINT           reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    WHILE           reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    FOR             reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    RETURN          reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    IF              reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)
    ID              reduce using rule 37 (expr -> mat_fun ( mat_fun_args ) .)


state 133

    (80) variables -> variables , expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ]               reduce using rule 80 (variables -> variables , expr .)
    ,               reduce using rule 80 (variables -> variables , expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 134

    (22) while_l -> WHILE ( expr ) error .
    {               reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    BREAK           reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    CONTINUE        reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    PRINT           reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    WHILE           reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    FOR             reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    RETURN          reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    IF              reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    ID              reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    $end            reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    }               reduce using rule 22 (while_l -> WHILE ( expr ) error .)
    ELSE            reduce using rule 22 (while_l -> WHILE ( expr ) error .)


state 135

    (24) while_l -> WHILE ( expr ) instruction .
    {               reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    BREAK           reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    CONTINUE        reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    PRINT           reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    WHILE           reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    FOR             reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    RETURN          reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    IF              reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    ID              reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    $end            reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    }               reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)
    ELSE            reduce using rule 24 (while_l -> WHILE ( expr ) instruction .)


state 136

    (23) while_l -> WHILE ( error ) instruction .
    {               reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    BREAK           reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    CONTINUE        reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    PRINT           reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    WHILE           reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    FOR             reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    RETURN          reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    IF              reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    ID              reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    $end            reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    }               reduce using rule 23 (while_l -> WHILE ( error ) instruction .)
    ELSE            reduce using rule 23 (while_l -> WHILE ( error ) instruction .)


state 137

    (25) for_l -> FOR ID = expr : . expr error
    (26) for_l -> FOR ID = expr : . error instruction
    (28) for_l -> FOR ID = expr : . expr instruction
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 144
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 143
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 138

    (27) for_l -> FOR ID = error : . expr instruction
    (36) expr -> . mat_fun ( error )
    (37) expr -> . mat_fun ( mat_fun_args )
    (38) expr -> . vector
    (39) expr -> . expr DOTSUB expr
    (40) expr -> . expr DOTADD expr
    (41) expr -> . expr DOTDIV expr
    (42) expr -> . expr DOTMUL expr
    (43) expr -> . expr OR expr
    (44) expr -> . expr AND expr
    (45) expr -> . expr XOR expr
    (46) expr -> . expr GREATEREQUAL expr
    (47) expr -> . expr LESSEREQUAL expr
    (48) expr -> . expr GREATER expr
    (49) expr -> . expr LESSER expr
    (50) expr -> . expr NOTEQUAL expr
    (51) expr -> . expr EQUAL expr
    (52) expr -> . expr / expr
    (53) expr -> . expr * expr
    (54) expr -> . expr - expr
    (55) expr -> . expr + expr
    (56) expr -> . unary
    (57) expr -> . ( expr )
    (58) expr -> . var
    (59) expr -> . FLOATNUM
    (60) expr -> . INTNUM
    (61) expr -> . STRING
    (83) mat_fun -> . ONES
    (84) mat_fun -> . EYE
    (85) mat_fun -> . ZEROS
    (78) vector -> . [ variables ]
    (75) unary -> . expr '
    (76) unary -> . NOT expr
    (77) unary -> . - expr
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    (               shift and go to state 33
    FLOATNUM        shift and go to state 38
    INTNUM          shift and go to state 39
    STRING          shift and go to state 40
    ONES            shift and go to state 41
    EYE             shift and go to state 42
    ZEROS           shift and go to state 43
    [               shift and go to state 44
    NOT             shift and go to state 45
    -               shift and go to state 35
    ID              shift and go to state 18

    expr                           shift and go to state 145
    mat_fun                        shift and go to state 32
    vector                         shift and go to state 34
    unary                          shift and go to state 36
    var                            shift and go to state 37
    matel                          shift and go to state 21

state 139

    (82) mat_fun_args -> mat_fun_args , expr .
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    ]               reduce using rule 82 (mat_fun_args -> mat_fun_args , expr .)
    ,               reduce using rule 82 (mat_fun_args -> mat_fun_args , expr .)
    )               reduce using rule 82 (mat_fun_args -> mat_fun_args , expr .)
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76


state 140

    (15) if_i -> IF ( expr ) instruction . ELSE error
    (20) if_i -> IF ( expr ) instruction . ELSE instruction
    (21) if_i -> IF ( expr ) instruction .
    ELSE            shift and go to state 146
    {               reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    BREAK           reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    CONTINUE        reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    PRINT           reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    WHILE           reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    FOR             reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    RETURN          reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    IF              reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    ID              reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    $end            reduce using rule 21 (if_i -> IF ( expr ) instruction .)
    }               reduce using rule 21 (if_i -> IF ( expr ) instruction .)


state 141

    (16) if_i -> IF ( expr ) error . ELSE instruction
    (17) if_i -> IF ( expr ) error .
    ELSE            shift and go to state 147
    {               reduce using rule 17 (if_i -> IF ( expr ) error .)
    BREAK           reduce using rule 17 (if_i -> IF ( expr ) error .)
    CONTINUE        reduce using rule 17 (if_i -> IF ( expr ) error .)
    PRINT           reduce using rule 17 (if_i -> IF ( expr ) error .)
    WHILE           reduce using rule 17 (if_i -> IF ( expr ) error .)
    FOR             reduce using rule 17 (if_i -> IF ( expr ) error .)
    RETURN          reduce using rule 17 (if_i -> IF ( expr ) error .)
    IF              reduce using rule 17 (if_i -> IF ( expr ) error .)
    ID              reduce using rule 17 (if_i -> IF ( expr ) error .)
    $end            reduce using rule 17 (if_i -> IF ( expr ) error .)
    }               reduce using rule 17 (if_i -> IF ( expr ) error .)


state 142

    (18) if_i -> IF ( error ) instruction . ELSE instruction
    (19) if_i -> IF ( error ) instruction .
    ELSE            shift and go to state 148
    {               reduce using rule 19 (if_i -> IF ( error ) instruction .)
    BREAK           reduce using rule 19 (if_i -> IF ( error ) instruction .)
    CONTINUE        reduce using rule 19 (if_i -> IF ( error ) instruction .)
    PRINT           reduce using rule 19 (if_i -> IF ( error ) instruction .)
    WHILE           reduce using rule 19 (if_i -> IF ( error ) instruction .)
    FOR             reduce using rule 19 (if_i -> IF ( error ) instruction .)
    RETURN          reduce using rule 19 (if_i -> IF ( error ) instruction .)
    IF              reduce using rule 19 (if_i -> IF ( error ) instruction .)
    ID              reduce using rule 19 (if_i -> IF ( error ) instruction .)
    $end            reduce using rule 19 (if_i -> IF ( error ) instruction .)
    }               reduce using rule 19 (if_i -> IF ( error ) instruction .)


state 143

    (25) for_l -> FOR ID = expr : expr . error
    (28) for_l -> FOR ID = expr : expr . instruction
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 149
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 150
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 144

    (26) for_l -> FOR ID = expr : error . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 151
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 145

    (27) for_l -> FOR ID = error : expr . instruction
    (39) expr -> expr . DOTSUB expr
    (40) expr -> expr . DOTADD expr
    (41) expr -> expr . DOTDIV expr
    (42) expr -> expr . DOTMUL expr
    (43) expr -> expr . OR expr
    (44) expr -> expr . AND expr
    (45) expr -> expr . XOR expr
    (46) expr -> expr . GREATEREQUAL expr
    (47) expr -> expr . LESSEREQUAL expr
    (48) expr -> expr . GREATER expr
    (49) expr -> expr . LESSER expr
    (50) expr -> expr . NOTEQUAL expr
    (51) expr -> expr . EQUAL expr
    (52) expr -> expr . / expr
    (53) expr -> expr . * expr
    (54) expr -> expr . - expr
    (55) expr -> expr . + expr
    (75) unary -> expr . '
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    DOTSUB          shift and go to state 59
    DOTADD          shift and go to state 60
    DOTDIV          shift and go to state 61
    DOTMUL          shift and go to state 62
    OR              shift and go to state 63
    AND             shift and go to state 64
    XOR             shift and go to state 65
    GREATEREQUAL    shift and go to state 66
    LESSEREQUAL     shift and go to state 67
    GREATER         shift and go to state 68
    LESSER          shift and go to state 69
    NOTEQUAL        shift and go to state 70
    EQUAL           shift and go to state 71
    /               shift and go to state 72
    *               shift and go to state 73
    -               shift and go to state 74
    +               shift and go to state 75
    '               shift and go to state 76
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 152
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 146

    (15) if_i -> IF ( expr ) instruction ELSE . error
    (20) if_i -> IF ( expr ) instruction ELSE . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    error           shift and go to state 154
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 153
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 147

    (16) if_i -> IF ( expr ) error ELSE . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 155
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 148

    (18) if_i -> IF ( error ) instruction ELSE . instruction
    (6) instruction -> . { instructions }
    (7) instruction -> . BREAK ;
    (8) instruction -> . CONTINUE ;
    (9) instruction -> . print_i ;
    (10) instruction -> . assign ;
    (11) instruction -> . while_l
    (12) instruction -> . for_l
    (13) instruction -> . return_i ;
    (14) instruction -> . if_i
    (32) print_i -> . PRINT error
    (33) print_i -> . PRINT printargs
    (65) assign -> . var DIVASSIGN error
    (66) assign -> . var MULASSIGN error
    (67) assign -> . var SUBASSIGN error
    (68) assign -> . var ADDASSIGN error
    (69) assign -> . var = error
    (70) assign -> . var DIVASSIGN expr
    (71) assign -> . var MULASSIGN expr
    (72) assign -> . var SUBASSIGN expr
    (73) assign -> . var ADDASSIGN expr
    (74) assign -> . var = expr
    (22) while_l -> . WHILE ( expr ) error
    (23) while_l -> . WHILE ( error ) instruction
    (24) while_l -> . WHILE ( expr ) instruction
    (25) for_l -> . FOR ID = expr : expr error
    (26) for_l -> . FOR ID = expr : error instruction
    (27) for_l -> . FOR ID = error : expr instruction
    (28) for_l -> . FOR ID = expr : expr instruction
    (29) return_i -> . RETURN error
    (30) return_i -> . RETURN expr
    (31) return_i -> . RETURN
    (15) if_i -> . IF ( expr ) instruction ELSE error
    (16) if_i -> . IF ( expr ) error ELSE instruction
    (17) if_i -> . IF ( expr ) error
    (18) if_i -> . IF ( error ) instruction ELSE instruction
    (19) if_i -> . IF ( error ) instruction
    (20) if_i -> . IF ( expr ) instruction ELSE instruction
    (21) if_i -> . IF ( expr ) instruction
    (62) var -> . ID
    (63) var -> . matel
    (64) matel -> . ID [ mat_fun_args ]
    {               shift and go to state 5
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PRINT           shift and go to state 14
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RETURN          shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 18

    instruction                    shift and go to state 156
    print_i                        shift and go to state 8
    assign                         shift and go to state 9
    while_l                        shift and go to state 10
    for_l                          shift and go to state 11
    return_i                       shift and go to state 12
    if_i                           shift and go to state 13
    var                            shift and go to state 15
    matel                          shift and go to state 21

state 149

    (25) for_l -> FOR ID = expr : expr error .
    {               reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    BREAK           reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    CONTINUE        reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    PRINT           reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    WHILE           reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    FOR             reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    RETURN          reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    IF              reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    ID              reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    $end            reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    }               reduce using rule 25 (for_l -> FOR ID = expr : expr error .)
    ELSE            reduce using rule 25 (for_l -> FOR ID = expr : expr error .)


state 150

    (28) for_l -> FOR ID = expr : expr instruction .
    {               reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    BREAK           reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    CONTINUE        reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    PRINT           reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    WHILE           reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    FOR             reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    RETURN          reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    IF              reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    ID              reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    $end            reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    }               reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)
    ELSE            reduce using rule 28 (for_l -> FOR ID = expr : expr instruction .)


state 151

    (26) for_l -> FOR ID = expr : error instruction .
    {               reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    BREAK           reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    CONTINUE        reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    PRINT           reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    WHILE           reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    FOR             reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    RETURN          reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    IF              reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    ID              reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    $end            reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    }               reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)
    ELSE            reduce using rule 26 (for_l -> FOR ID = expr : error instruction .)


state 152

    (27) for_l -> FOR ID = error : expr instruction .
    {               reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    BREAK           reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    CONTINUE        reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    PRINT           reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    WHILE           reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    FOR             reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    RETURN          reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    IF              reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    ID              reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    $end            reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    }               reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)
    ELSE            reduce using rule 27 (for_l -> FOR ID = error : expr instruction .)


state 153

    (20) if_i -> IF ( expr ) instruction ELSE instruction .
    {               reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    BREAK           reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    PRINT           reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    WHILE           reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    FOR             reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    RETURN          reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    IF              reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    ID              reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    $end            reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    }               reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)
    ELSE            reduce using rule 20 (if_i -> IF ( expr ) instruction ELSE instruction .)


state 154

    (15) if_i -> IF ( expr ) instruction ELSE error .
    {               reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    BREAK           reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    CONTINUE        reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    PRINT           reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    WHILE           reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    FOR             reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    RETURN          reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    IF              reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    ID              reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    $end            reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    }               reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)
    ELSE            reduce using rule 15 (if_i -> IF ( expr ) instruction ELSE error .)


state 155

    (16) if_i -> IF ( expr ) error ELSE instruction .
    {               reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    BREAK           reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    CONTINUE        reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    PRINT           reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    WHILE           reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    FOR             reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    RETURN          reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    IF              reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    ID              reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    $end            reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    }               reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)
    ELSE            reduce using rule 16 (if_i -> IF ( expr ) error ELSE instruction .)


state 156

    (18) if_i -> IF ( error ) instruction ELSE instruction .
    {               reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    BREAK           reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    PRINT           reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    WHILE           reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    FOR             reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    RETURN          reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    IF              reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    ID              reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    $end            reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    }               reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
    ELSE            reduce using rule 18 (if_i -> IF ( error ) instruction ELSE instruction .)
